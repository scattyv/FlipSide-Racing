#tag ClassProtected Class SerialLapCountersInherits Serial	#tag Event		Sub DataAvailable()		  select case hardwaretype		    		  case "AMB20"		    buffer = buffer + me.ReadAll		    //IR based hardware that emulates the old AMB protocol		    ReadAMB20Data		    		  case "CoreSpeedway","CoreSpeedway i166"		    ReadS6350Data		    		  case "Kyosho IC"		    		    //Dump the data into the buffer and then process		    buffer = buffer + me.ReadAll		    		    //Old method of reading data, no longer needed		    		    //dim rawbytes as string = me.ReadAll		    //dim hexCode as string		    //dim HexCommandCount as Integer		    		    //hexCode = convertToHex(rawbytes)		    		    //Fill the array with the hex commands as they come in~		    //HexCommandCount = CountFields(hexCode," ")		    //for i as Integer=1 to HexCommandCount		    //assembledHex.Append nthfieldb(hexCode," ",i)		    //next		    		    		    ReadKyoshoICData		    		  case "Robitronic"		    		    //Dump data into the buffer and process the buffer		    buffer = buffer + me.ReadAll		    		    ReadRobitronicData		    		  case "I-Lap"		    //Dump data into the buffer and process		    buffer = buffer + me.ReadAll		    ReadILapData		    		  case "WanhaRacing"		    //Dump data into the buffer and process		    buffer = buffer + me.ReadAll		    ReadWanhaRacingData		    		  case "GKA9805"		    //Dump data into buffer and process		    buffer = buffer + me.ReadAll		    ReadGKA9805Data		    		  case "GiroZ USB"		    //Dump data into buffer and process		    buffer = buffer + me.ReadAll		    ReadGiroZData		    		  case "Trackmate"		    //Dump data into buffer and process		    buffer = buffer + me.ReadAll		    ReadTrackmateData		    		  case "AMBrc"		    //Dump data into buffer and process		    buffer = buffer + me.ReadAll		    ReadAMBrcData		    		  case "Flip Side Dio"		    //Dump data into buffer and process		    buffer = buffer + me.ReadAll		    ReadFSDIOData		    		  case "DCD TimeR"		    //Dump data into buffer and process		    buffer = buffer + me.ReadAll		    ReadDCDData		    		  case "LapZ"		    //Dump data into buffer and process		    buffer = buffer + me.ReadAll		    ReadLapZData		    		  case "Flip Side Alpha"		    //Dump data into buffer and process		    buffer = buffer + me.ReadAll		    ReadFSAlphaData		    		  case "Cano"		    //Dump data into buffer and process		    buffer = buffer + me.ReadAll		    ReadCanoData		    		  else		    //No hardware type, discard data		    buffer = me.ReadAll		    buffer =""		    		  end select		End Sub	#tag EndEvent	#tag Method, Flags = &h0		Function canPause() As Boolean		  //Returns a boolean indicating whether or not this lap counter hardware supports pausing		  dim response as boolean		  response = false		  		  select case hardwaretype		  case "Flip Side Dio"		    response = True		  case "GKA9805"		    response = True		  case "Kyosho IC"		    response = True		  case "WanhaRacing"		    response = True		  case "GiroZ USB"		    response = True		  case "CoreSpeedway"		    response = True		  case "CoreSpeedway i166"		    response = True		  case "Flip Side Alpha"		    response = True		  else		    response = false		  end select		  		  return response		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function canScan() As Boolean		  //Identify if the hardware is capable of scanning for UID's without having to send repeated inventory commands		  //The default is true, most lap counters operate this way, if not please add it below as false		  dim default as boolean		  		  default = True		  		  select case hardwaretype		    		  case "CoreSpeedway"		    default = False		  case "CoreSpeedway i166"		    default = False		    		  end select		  		  return default		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function convertToHex(data as string) As string		  dim hexPart as string		  dim hexString as string		  		  for i as Integer=1 to lenb(data)		    hexPart = hex(ascb(midb(data,i,1)))		    if lenb(hexPart)<2 then		      hexpart="0"+hexPart		    end if		    if i<>lenb(data) then		      hexString=hexString+hexPart+" "		    else		      hexString=hexString+hexPart//so we don't get extra space at end throwing off command size		    end if		  next		  		  return hexString		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub getReaderVersion()		  //This command is used to determine the version of the hardware we are dealing with		  dim versionCommand as string		  		  commandmode = "version"		  		  select Case hardwaretype		    		  case "CoreSpeedway","CoreSpeedway i166"		    versionCommand = ChrB(&h01) + ChrB(&h09) + ChrB(&h00) + ChrB(&h00) + ChrB(&h00) + ChrB(&h00) + ChrB(&hF0) + ChrB(&hF8) + ChrB(&h07)		    me.Write(versionCommand)		    		  end select		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub initialize()		  //used for any initialization commands needed		  dim initCommand as string		  		  		  		  select case hardwaretype		    		  Case "CoreSpeedway","CoreSpeedway i166"		    commandmode = "init"		    initCommand = ChrB(&h01) + ChrB(&h0A) + ChrB(&h00) + ChrB(&h00) + ChrB(&h00) + ChrB(&h00) + ChrB(&hF4) + ChrB(&h00) + ChrB(&hFF) + ChrB(&h00)		    me.Write(initCommand)		    		  case "I-Lap"		    //Set the command mode to polling as this command both initializes the hardware and starts the polling		    		    commandmode = "polling"		    		    initCommand = ChrB(&h01) + ChrB(&h25) + ChrB(&h0D) + ChrB(&h0A)		    me.Write(initCommand)		    		  case "Trackmate"		    		    //Set the mode for decoding data		    commandmode = "polling"		    //start polling by initializing		    initCommand = ChrB(&h01) + ChrB(&h3F) + ChrB(&h2C) + ChrB(&h32) + ChrB(&h30) + ChrB(&h32) + ChrB(&h2C) + ChrB(&h30) + ChrB(&h2C) + ChrB(&h31) + ChrB(&h31) + ChrB(&h2C) + ChrB(&h0D) + ChrB(&h0A)		    me.Write(initCommand)		    		    //case "AMBrc"		    //Set the mode for decoding data		    //commandmode = "init"		    //Blank command		    //initCommand = ChrB(&h01) + ChrB(&h0D) + ChrB(&h0A)		    //Transmit twice just in case		    //This command should provide the Decoder ID in response		    //me.Write(initCommand)		    //me.XmitWait		    //me.Write(initCommand)		    //start polling by initializing		    //initCommand = ChrB(&h01) + ChrB(&h3F) + ChrB(&h2C) + ChrB(&h32) + ChrB(&h30) + ChrB(&h32) + ChrB(&h2C) + ChrB(&h30) + ChrB(&h2C) + ChrB(&h31) + ChrB(&h31) + ChrB(&h2C) + ChrB(&h0D) + ChrB(&h0A)		    //me.Write(initCommand)		    		  case "LapZ"		    //Set mode		    commandmode = "polling"		    //reset lap timer		    initCommand = ChrB(&h23) + ChrB(&h53) + ChrB(&h24)		    me.Write(initCommand)		    		    		  end select		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub inv1Slot()		  dim invcommand as string		  		  //set commandmode to define how data will be decoded		  		  		  select case hardwaretype		    		  case "CoreSpeedway","CoreSpeedway i166"		    commandmode = "inventory"		    'This sends an ISO15693 inventory command for the TI S6350 reader		    'Does an inventory of just 1 time slot, this allows faster inventory responses but can not handle collisions		    'To minimize collisions silence the tag after it is detected		    'Byte 1 is the Start of Frame, always 01		    'Byte 2 and 3 is the length of the command including the 2 byte check sum that is added to the end, Least Significant Byte first		    'Byte 4 and 5 is the node address, leave at 00 as we do not reference nodes		    'Byte 6 is the command flags, no flags present		    'Byte 7 is the command, &h60 means it is an ISO15693 command which will be in the data portion of the packet		    'Byte 8 is the config byte for the reader, &h11 means 100% modulation and 1/4 data mode		    'Byte 9 is the ISO15693 command flags, &h27 means 2 sub carriers, high data rate, inventory_flag set, nb_slots_flag set to 1 slot		    'Byte 10 is the ISO15693 command, &h01 means inventory		    'Byte 11 is the optional mask that is not set		    'Bytes 12 and 13 are the checksum		    invcommand = ChrB(&h01) + ChrB(&h0D) + ChrB(&h00) + ChrB(&h00) + ChrB(&h00) + ChrB(&h00) + ChrB(&h60) + ChrB(&h11) + ChrB(&h27) + ChrB(&h01) + ChrB(&h00) + ChrB(&h5B) + ChrB(&hA4)		    me.Write(invcommand)		    		  case "Kyosho IC"		    commandmode = "inventory"		    'This is for the Kyosho IC home edition lap counter		    'This works only for ISO14443 tags		    'Checksum is a XOR operation		    		    invcommand = ChrB(&h35) + ChrB(&h03) + ChrB(&h36)		    me.Write(invcommand)		    		  end select		  		  		  		  return		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub invAllSlots()		  'This sends an ISO15693 inventory command for the TI S6350 reader		  'Does an inventory of all time slots, this supports anti-collision but is too slow to use during a race		  'takes about .3 seconds to return results		  		  //set commandmode to define how data will be decoded		  		  		  select case hardwaretype		  case "CoreSpeedway","CoreSpeedway i166"		    commandmode = "inventory"		    dim invcommand as string		    		    'Byte 1 is the Start of Frame, always 01		    'Byte 2 and 3 is the length of the command including the 2 byte check sum that is added to the end, Least Significant Byte first		    'Byte 4 and 5 is the node address, leave at 00 as we do not reference nodes		    'Byte 6 is the command flags, no flags present		    'Byte 7 is the command, &h60 means it is an ISO15693 command which will be in the data portion of the packet		    'Byte 8 is the config byte for the reader, &h11 means 100% modulation and 1/4 data mode		    'Byte 9 is the ISO15693 command flags, &h07 means 2 sub carriers, high data rate, inventory_flag set, nb_slots_flag set to all 16 slots		    'Byte 10 is the ISO15693 command, &h01 means inventory		    'Byte 11 is the optional mask that is not set		    'Bytes 12 and 13 are the checksum		    invcommand = chrB(&h01) + chrB(&h0D) + chrB(&h00) + chrB(&h00) + chrB(&h00) + chrB(&h00) + chrB(&h60) + chrB(&h11) + chrB(&h07) + chrB(&h01) + chrB(&h00) + chrB(&h7B) + chrB(&h84)		    		    me.Write(invcommand)		    		  case "Kyosho IC"		    commandmode = "inventory"		    //Do not have command for multiple slot inventory so perform a single slot inventory		    inv1Slot		    		    		  end select		  		  		  return		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function lapTimeFormat() As string		  //Identifies the lap time format string based on hardware type		  dim format as string		  		  format = "0.00"		  		  select case hardwaretype		    		  case "I-Lap","Robitronic","GiroZ USB","Trackmate","AMBrc","Flip Side Dio","DCD TimeR","LapZ","Flip Side Alpha","Cano"		    format = "0.000"		  else		    format = "0.00"		  end select		  		  return format		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub lightState(stateName as string = "off")		  //This method controls any hardware lights that may be supported by the lap counter		  		  //Valid states are currently start, stop, two, three, off and on		  //States two and three are only used during a count down and not really needed		  		  dim commandString as string		  		  select case hardwaretype		  case "Flip Side Dio"		    		    //Now determine the command we need to send		    //The protocol is simple, Q, W, E and R will turn off lights 1 through 4		    //1, 2, 3, 4 turn on lights 1 through 4		    //Light 1 is the start light, 2 is two, 3 is three and 4 is the stop light		    		    select case stateName		      		    case "start"		      commandString = "1WER"		    case "stop"		      commandString = "QWE4"		    case "two"		      commandString = "Q2ER"		    case "three"		      commandString = "QW3R"		    case "on"		      commandString = "1234"		    case "ending"		      commandString = "1WER"		    else		      //Turn them off otherwise		      commandString = "QWER"		    end select		    		    //Write the command out		    me.Write(commandString)		    		  end select		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub polling(enabled as Boolean)		  dim sendstring as string		  		  select case hardwaretype		    		  case "Kyosho IC"		    if enabled = true then		      //Clear the buffer		      buffer = ""		      //Start polling		      //Change command mode so that dataavailable event will know how to decode data		      commandmode = "polling"		      //Command to start polling mode		      sendstring = ChrB(&h31) + ChrB(&h04) + ChrB(&h01) + ChrB(&h34)		      //Send command		      me.Write(sendstring)		      		    else		      //Stop polling		      //Change the command mode		      commandmode = "none"		      //Command to stop polling mode		      sendstring = ChrB(&h32) + ChrB(&h03) + ChrB(&h31)		      //Send command		      me.Write(sendstring)		      //clear the buffer		      buffer = ""		      		    end if		    		  case "Robitronic"		    if enabled = true then		      //Clear the buffer		      buffer = ""		      //Set the command mode so dataavailable event knows what to do		      commandmode = "polling"		      //set command to send		      sendstring = ChrB(&h03) + ChrB(&hB9) + ChrB(&h01)		      //Send command		      me.Write(sendstring)		      me.XmitWait		      me.Write(sendstring)		      me.XmitWait		      me.Write(sendstring)		      		    else		      //No need to turn off mode		      		    end if		    		  case "GKA9805"		    if enabled = true then		      //Clear buffer		      buffer = ""		      commandmode = "polling"		      sendstring = ChrB(&h7C) + ChrB(&hFF) + ChrB(&hFF) + ChrB(&h01) + ChrB(&h08) + ChrB(&h7D)		      //Set it to polling mode		      me.Write(sendstring)		      		    end if		    		  case "I-Lap"		    		    //Enable the I-lap lap counter to poll, there is no known stop command		    if enabled = true then		      //Clear the buffer		      buffer = ""		      //Set the mode for decoding data		      commandmode = "polling"		      //start polling by initializing		      sendstring = ChrB(&h01) + ChrB(&h25) + ChrB(&h0D) + ChrB(&h0A)		      me.Write(sendstring)		      		      		    end if		    		  case "GiroZ USB"		    		    //Enable the GiroZ lap counter to poll, there is no known stop command		    if enabled = true then		      //Clear the buffer		      buffer = ""		      //Set the mode for decoding data		      commandmode = "polling"		      		    end if		    		  case "Trackmate"		    		    //Enable the Trackmate lap counter to poll, there is no known stop command		    if enabled = true then		      //Clear the buffer		      buffer = ""		      //Set the mode for decoding data		      commandmode = "polling"		      //start polling by initializing		      sendstring = ChrB(&h01) + ChrB(&h3F) + ChrB(&h2C) + ChrB(&h32) + ChrB(&h30) + ChrB(&h32) + ChrB(&h2C) + ChrB(&h30) + ChrB(&h2C) + ChrB(&h31) + ChrB(&h31) + ChrB(&h2C) + ChrB(&h0D) + ChrB(&h0A)		      me.Write(sendstring)		      		      		    end if		    		  case "AMBrc"		    //Enable the AMBrc lap counter to poll, there is no known stop command		    if enabled = true then		      //Clear the buffer		      buffer = ""		      //Set the mode for decoding data		      commandmode = "polling"		      //start polling by initializing		      sendstring = ChrB(&h01) + ChrB(&h3F) + ChrB(&h2C) + decoderID + ChrB(&h2C) + ChrB(&h30) + ChrB(&h2C) + ChrB(&h31) + ChrB(&h31) + ChrB(&h2C) + ChrB(&h0D) + ChrB(&h0A)		      me.Write(sendstring)		      		    end if		    		  case "Flip Side Dio"		    //Clear the buffer and set the decoding method		    if enabled = true then		      //Clear the buffer		      buffer = ""		      //Set the mode for decoding data		      commandmode = "polling"		      		    end if		    		  case "DCD TimeR"		    //Clear the buffer and set command mode so it will read the data		    if enabled = true then		      buffer = ""		      		      commandmode = "polling"		      		    end if		    		  case "LapZ"		    		    //Enable the LapZ to poll		    if enabled = true then		      //Clear the buffer		      buffer = ""		      //Set the mode for decoding data		      commandmode = "polling"		      //start polling by initializing		      sendstring = ChrB(&h23) + ChrB(&h53) + ChrB(&h24)		      me.Write(sendstring)		      		    else		      //Stop polling		      //Change the command mode		      commandmode = "none"		      //Command to stop polling mode		      sendstring = ChrB(&h23) + ChrB(&h46) + ChrB(&h24)		      //Send command		      me.Write(sendstring)		      //clear the buffer		      buffer = ""		      		    end if		    		  case "Flip Side Alpha"		    //Clear the buffer and set the decoding method		    if enabled = true then		      //Clear the buffer		      buffer = ""		      //Set the mode for decoding data		      commandmode = "polling"		      		    end if		    		  case "Cano"		    //Clear the buffer and set the decoding method		    if enabled = true then		      //Clear the buffer		      buffer = ""		      //Set the mode for decoding data		      commandmode = "polling"		      		    end if		    		  end select		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadAMB20Data()		  //This method is incomplete		  //This protocol is similar to the old AMB protocol		  //If a UID is detected then trigger the DetectedUIDs Event Definition		  dim bufferarray() as string		  dim ids as string		  dim item as string		  dim lasttwo as string		  		  		  //two different data packets can arrive, one is just a time stamp, the other is a car id and time stamp		  //The time stamp comes in like this @00000277 which is the number of seconds the hardware was running		  //In this case it is 4 minutes and 37 seconds		  //The car ID comes in like this @010204382050		  //The car ID immediately follows the @ sign		  //The after that is the time in the format HHMMSSss		  //followed by the number of transponder hits(how many times it was detected under the bridge)		  //Each data packet is followed by two non printable characters &h 0D (15) carriage return and &h0A (10) line feed		  		  bufferarray = buffer.splitb(chrb(13) + chrb(10))		  		  lasttwo = buffer.rightb(2)		  //Clear buffer as we have the info stored locally now		  buffer = ""		  		  //Check the last entry of the buffer array to see if it is complete, if not put it back in the buffer so it can be appended by the dataavailable event		  if lasttwo <> chrb(13) + chrb(10) then		    //do not have a finished packet here, add it back to the buffer		    item = bufferarray.Pop		    buffer = item + buffer		  end if		  		  //Make sure we have something left in the array		  if UBound(bufferarray) > -1 then		    //Now check each of the remaining packets		    for each element as string in bufferarray		      		      // Make sure we have the beginning of a packet		      if element.instrb("@") = 1 then		        		        //We have the beginning, make sure it is the right length		        if element.lenb = 13 then		          //We have a packet with a uid in it, now we extract the uid		          ids = element.midb(2,2)		        end if		        		      else		        //This packet is broken so we do not use it, continue on		      end if		      //Check next element		    next		    		    //Check to see if we have any ids, if so pass them to the DetectedUIDs Event Definition so that the program using this class can get this data		    if lenb(ids) > 0 then		      DetectedUIDs(ids,0)		    end if		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadAMBrcData()		  //For the AMBrc hardware there are two known response packets		  //To start the lap counter timer you must send the following command		  // 01 3F 2C 32 30 32 2C 30 2C 31 31 2C 0D 0A		  //Each packet ends with a Control Line Feed, 0D 0A		  		  //Multiple types of packets are sent from the lap counter, one is a time packet sent periodically and the other is a transponder packet		  //All packets start with 01 and end with 0D 0A		  		  //The time packet will have byte 2 set to 23, the # character		  		  //The transponder packet with have byte 2 set to 40, the @ character		  //The fields in the transponder packet are seperated by 09, the Tab character		  //Field 1 is the header, 01 40		  //Field 2 is unknown		  //Field 3 is the transponder number		  //Field 4 is the time stamp, convert to a number and multiply by 1000 to get the time in milliseconds		  //Field 5 is the number of hits the transponder had		  		  //If a blank command was sent then the decoder ID should be received		  //The decoderID packet is seperated by tabs		  //Field 1 is the header, 01 24		  //Field 2 is the decoder ID in ascii text		  //Field 3 is unknown, 7 in provided example		  //Field 4 is unknown, 0 in provided example		  //Field 5 is unknown, 1 in provided example		  //Field 6 is unknown, 1 in provided example		  //Field 7 is unknown, F8 F9 in provided example		  //and the packet ends with the standard 0D 0A		  //So an example packet could be		  // 01 24 09 31 35 34 09 37 09 30 09 31 09 31 09 F8 F9 0D 0A		  // This would be decoder ID 154		  		  dim flagStart,flagEnd as Integer = -1		  dim uids as string		  dim subbuf as string		  dim splitbuf() as string		  dim splitCount as integer		  dim tempUID as string		  dim tempTime as double		  		  //Make sure we are not already analyzing data		  if processing = false then		    		    processing = true		    		    //Check which command type is happening to determine how to decode data		    select case commandmode		      		    case "inventory", "polling"		      		      //Check to see if we have enough data in the buffer to process		      if lenb(buffer) < 4 then		        //Not enough data to care		        processing = false		        Return		      end if		      		      //Check to see if we have a valid packet		      flagStart = InStrb(buffer, ChrB(&h01))		      flagEnd = InStrB(buffer, ChrB(&h0A))		      //If 0 is returned then we do not have a beginning of a packet, data can be discarded		      if flagStart = 0 then		        //no good data,		        //flush it all		        buffer = ""		        processing = false		        return		      ElseIf flagEnd = 0 then		        // we do not have a complete packet return and wait		        processing = false		        return		      end if		      		      //Make sure we do not have an end of a packet stuck in the buffer, if so discard that data and start over		      if flagEnd < flagStart then		        //oops we have bad data before flagstart and need to discard that data check to see if we have another end		        buffer = RightB(buffer,lenb(buffer) -flagStart + 1)		        		        flagEnd = InStrB(buffer, ChrB(&h0A))		        		        if flagEnd = 0 then		          //Not enough data to continue yet		          processing = false		          return		        end if		      end if		      		      //make sure we have a transponder packet		      //If not get rid of the packet		      if buffer.midb(flagStart+1,1) <> "@" and flagEnd < lenB(buffer) then		        //We must have some other packet not a transponder packet		        //Discard this data and continue one		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		        processing = false		        return		      elseif buffer.midb(flagStart+1,1) <> "@" and flagEnd = lenB(buffer) then		        buffer = ""		        processing = false		        return		      end if		      		      //take the substring to work with		      subbuf = MidB(buffer, flagStart, flagEnd-flagStart+1)		      //Split it out		      splitbuf = splitb(subbuf, chrb(&h09))		      		      splitCount = UBound(splitbuf)		      		      //Check to see that we have enough elements in array, if so then use the transponder id, otherwise discard the data		      if splitCount > 4 then		        tempUID = splitbuf(3)		        //Time in packet is in seconds, we need to send it in microseconds		        tempTime = val(splitbuf(4))*1000000.0		        uids = tempUID		        		      else		        //Not a valid transponder packet we need to discard it		        if flagEnd = lenB(buffer) then		          buffer = ""		          processing = false		          return		        else		          buffer = RightB(buffer,lenb(buffer) - flagEnd)		          processing = false		          return		        end if		        		      end if		      		      //Clear out the processed data		      if flagEnd < lenb(buffer) then		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		      else		        buffer = ""		      end if		      		      DetectedUIDs(uids,tempTime)		    case "init"		      //When an init command occurs we should get back a packet that includes the decoder id which is needed for future packets		      		      //Check to see if we have enough data in the buffer to process		      if lenb(buffer) < 4 then		        //Not enough data to care		        processing = false		        Return		      end if		      		      //Check to see if we have a valid packet		      flagStart = InStrb(buffer, ChrB(&h01))		      flagEnd = InStrB(buffer, ChrB(&h0A))		      //If 0 is returned then we do not have a beginning of a packet, data can be discarded		      if flagStart = 0 then		        //no good data,		        //flush it all		        buffer = ""		        processing = false		        return		      ElseIf flagEnd = 0 then		        // we do not have a complete packet return and wait		        processing = false		        return		      end if		      		      //Make sure we do not have an end of a packet stuck in the buffer, if so discard that data and start over		      if flagEnd < flagStart then		        //oops we have bad data before flagstart and need to discard that data check to see if we have another end		        buffer = RightB(buffer,lenb(buffer) -flagStart + 1)		        		        flagEnd = InStrB(buffer, ChrB(&h0A))		        		        if flagEnd = 0 then		          //Not enough data to continue yet		          processing = false		          return		        end if		      end if		      		      //make sure we have an init packet		      //If not get rid of the packet		      if buffer.midb(flagStart+1,1) <> "$" and flagEnd < lenB(buffer) then		        //We must have some other packet not a transponder packet		        //Discard this data and continue one		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		        processing = false		        return		      elseif buffer.midb(flagStart+1,1) <> "$" and flagEnd = lenB(buffer) then		        buffer = ""		        processing = false		        return		      end if		      		      //take the substring to work with		      subbuf = MidB(buffer, flagStart, flagEnd-flagStart+1)		      //Split it out		      splitbuf = splitb(subbuf, chrb(&h09))		      		      splitCount = UBound(splitbuf)		      		      //Check to see that we have enough elements in array, if so then use the decoder id, otherwise discard the data		      if splitCount > 4 then		        decoderID = splitbuf(1)		        		        //Now that we have a valid decoder ID we can switch its mode to AMBrc		        me.Write(ChrB(&h01) + ChrB(&h3F) + ChrB(&h2C) + decoderID + ChrB(&h2C) + ChrB(&h30) + ChrB(&h2C) + ChrB(&h33) + ChrB(&h37) + ChrB(&h2C) + ChrB(&h30) + ChrB(&h2C) + ChrB(&h0D) + ChrB(&h0A))		        //Also reset the timer		        me.XmitWait		        resetTimer		        		      else		        //Not a valid decoder packet we need to discard it		        if flagEnd = lenB(buffer) then		          buffer = ""		          processing = false		          return		        else		          buffer = RightB(buffer,lenb(buffer) - flagEnd)		          processing = false		          return		        end if		        		      end if		      		      //Clear out the processed data		      if flagEnd < lenb(buffer) then		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		      else		        buffer = ""		      end if		      		      		    else		      //We are getting data but no command was issued, discard data		      buffer = ""		      		    end select		    		    //done processing set to false		    processing = false		    		  end if		  		  		  //check to see if there is data still to process		  if lenb(buffer) > 15 then		    ReadAMBrcData		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadCanoData()		  //Cano packets are in an Ascii format, each pair of Ascii characters represents 1 byte and 16 bytes in length		  //The packet consists of a 6 byte UID, an 8 Byte time stamp and 2 byte ending characters, CR/LF		  //For the UID we will use the Ascii data exactly as provided		  //For the time stamp we must convert it, the time stamp is in 1/4 milliseconds		  //Example Cano packet excluding the CR/LF at the end		  //CDFD4C00FFB6DA (CR/LF)		  //Raw view of the packet		  // 43 44 46 44 34 43 30 30 46 46 42 36 44 41 0D 0A		  //Bytes 1-6 are the UID, CDFD4C in ascii		  //Bytes 7-14 are the timestamp, 00FFB6DA in ascii, 16758490 in 1/4 milliseconds, 4189.6225 in seconds		  //Bytes 15-16 are the end of the packet 0D 0A, or CR/LF		  		  //Another example would be		  //CDFD4C0100531A (CR/LF)		  //Raw view of packet		  // 43 44 46 44 34 43 30 31 30 30 35 33 31 41 0D 0A		  //Bytes 1-6 are the UID, CDFD4C in ascii		  //Bytes 7-14 are the timestamp, 0100531A, 16798490 in 1/4 milliseconds, 4199.6225 in seconds		  //Bytes 15-16 are the end of the packet 0D 0A, or CR/LF		  		  		  //To reset the timer within the lap counter send a 00		  		  dim flagStart,flagEnd as Integer = -1		  dim uids as string		  dim subbuf as string		  dim tempTime as double		  dim timeString as string		  		  //Make sure we are not already analyzing data		  if processing = false then		    		    processing = true		    		    //Check which command type is happening to determine how to decode data		    select case commandmode		      		    case "inventory", "polling"		      		      //Check to see if we have enough data in the buffer to process		      if lenb(buffer) < 16 then		        //Not enough data to care		        processing = false		        Return		      end if		      		      //Check to see if we have a valid packet		      		      //The start of the packet is always at 1 because Cano packets do not have a header		      		      flagEnd = InStrB(buffer, ChrB(&h0A))		      flagStart = flagEnd - 15		      //If 0 is returned then we do not have a beginning of a packet, data can be discarded		      if flagEnd = 0 then		        // we do not have a complete packet return and wait		        processing = false		        return		      end if		      		      		      //make sure we have a transponder packet		      //If not get rid of the packet		      if flagStart < 1 and flagEnd < lenB(buffer) then		        //We must have some other packet not a transponder packet		        //Discard this data and continue one		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		        processing = false		        ReadCanoData		        return		      elseif flagStart < 1 and flagEnd = lenB(buffer) then		        buffer = ""		        processing = false		        return		      end if		      		      //take the substring to work with		      subbuf = MidB(buffer, flagStart, flagEnd-flagStart+1)		      		      //Get bytes 1 through 6 for the UID		      uids = MidB(subbuf, 1, 6)		      		      //Get the time, which is bytes 5 to end - 2		      timeString = MidB(subbuf, 7, 8)		      		      //Time is in an ascii encoded hex 1/4 milliseconds, we must convert this to microseconds double		      tempTime = val("&h" + timeString) * 250		      		      		      //Clear out the processed data		      if flagEnd < lenb(buffer) then		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		      else		        buffer = ""		      end if		      		      DetectedUIDs(uids,tempTime)		      		    else		      //We are getting data but no command was issued, discard data		      buffer = ""		      		    end select		    		    //done processing set to false		    processing = false		    		  end if		  		  		  		  //check to see if there is data still to process		  if lenb(buffer) > 15 then		    ReadCanoData		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadDCDData()		  //For the DCD hardware there are three known response packets		  //To sync the time with the lap counter timer you must send the following command		  // 31 0D		  //Each response packet ends with a Control Line Feed, 0D 0A		  		  //Four types of packets are sent from the lap counter, one is a time packet sent periodically and the other is a transponder packet		  //All packets are plain text, each response packet begins with a type followed by a : and space		  		  //A packet is sent for a detected transponder with the following format		  //Bytes 1 through 4 are 49 44 3A 20 which is ID: followed by a space		  //Bytes 5-8 are the ID, for example 32 34 36 37 which translates to 2467		  //Byte 9 is a space		  //Bytes 10-15 are the time in milliseconds, for example 33 33 34 39 34 37 which translates to 334947 milliseconds,		  //You must have done a sync at the beginning of the race and stored that time to calculate the lap time		  //Bytes 16-17 are the end of the packet, a control line feed 0D 0A		  //The whole packet in this case would look like 49 44 3A 20 32 34 36 37 20 33 33 34 39 34 37 0D 0A		  		  //A second packet type is the response packet to the sync command		  //We must have a sync time to calculate lap times from as the timer in the lap counter does not reset with each race		  //This packet will tell you the time the lap counter thinks it current is in milliseconds, the format is the following		  //Bytes 1 through 6 are 53 59 4E 43 3A 20 which is SYNC: followed by a space		  //Bytes 7-12 are the current time in milliseconds, for example 33 34 32 35 30 31 which is 342501		  //Byte 13 is 20 which is a space		  //Byte 14 and 15 are the control line feed for the end of the packet 0D 0A		  //The whole packet in this case would look like 53 59 4E 43 3A 20 33 34 32 35 30 31 20 0D 0A		  		  //A third packet type is sent every second not much is known about this packet yet		  //Bytes 1 through 6 is 4D 45 41 53 3A 20 which is MEAS: followed by a space		  //Bytes 7 through 13 is a number to the 10 thousands place followed by a space, maybe a temperature		  //An example is 34 2E 30 37 33 34 20 which is 4.0734		  //Bytes 14-16 are another number this time an integer, possibly the charge		  //An example is 35 30 39 which is 509		  //Bytes 17 -18 are the end of the packet, control line feed 0D 0A		  //So the whole packet would be 4D 45 41 53 3A 20 34 2E 30 37 33 34 20 35 30 39 0D 0A		  		  //A fourth packet type occurs every second or so and is unknown of its purpose		  //Bytes 1 through 3 are 48 42 3A which is HB:		  //Bytes 4 through 6 are a number that appears to not change for example 31 30 36 which is 106		  //Bytes 7 and 8 are the end of the packet, control line feed 0D 0A		  //For example a whole packet would look like 48 42 3A 31 30 36 0D 0A		  		  dim flagStart,flagEnd as Integer = -1		  dim uids as string		  dim subbuf as string		  dim splitbuf() as string		  dim splitCount as integer		  dim tempUID as string		  dim tempTime as double		  		  //syncTime is a value populated at the beginning of each race since the clock on the lap counter does not reset		  static syncTime as double		  		  //Make sure we are not already analyzing data		  if processing = false then		    		    processing = true		    		    //Check which command type is happening to determine how to decode data		    select case commandmode		      		    case "inventory", "polling"		      		      //Check to see if we have enough data in the buffer to process		      if lenb(buffer) < 4 then		        //Not enough data to care		        processing = false		        Return		      end if		      		      //Check to see if we have a valid packet		      flagStart = InStrb(buffer, ChrB(&h49))		      flagEnd = InStrB(buffer, ChrB(&h0A))		      //If 0 is returned then we do not have a beginning of a packet, data can be discarded		      if flagStart = 0 then		        //no good data,		        //flush it all		        buffer = ""		        processing = false		        return		      ElseIf flagEnd = 0 then		        // we do not have a complete packet return and wait		        processing = false		        return		      end if		      		      //Make sure we do not have an end of a packet stuck in the buffer, if so discard that data and start over		      if flagEnd < flagStart then		        //oops we have bad data before flagstart and need to discard that data check to see if we have another end		        buffer = RightB(buffer,lenb(buffer) -flagStart + 1)		        		        flagEnd = InStrB(buffer, ChrB(&h0A))		        		        if flagEnd = 0 then		          //Not enough data to continue yet		          processing = false		          return		        end if		      end if		      		      //make sure we have a transponder packet		      //If not get rid of the packet		      if buffer.midb(flagStart+1,1) <> ChrB(&h44) and flagEnd < lenB(buffer) then		        //We must have some other packet not a transponder packet		        //Discard this data and continue one		        buffer = RightB(buffer,len(buffer) - flagEnd)		        processing = false		        return		      elseif buffer.midb(flagStart+1,1) <> ChrB(&h44) and flagEnd = lenB(buffer) then		        buffer = ""		        processing = false		        return		      end if		      		      //take the substring to work with		      subbuf = MidB(buffer, flagStart, flagEnd-flagStart+1)		      //Split it out		      splitbuf = split(subbuf, chrb(&h20))		      		      splitCount = UBound(splitbuf)		      		      //Check to see that we have enough elements in array, if so then use the transponder id, otherwise discard the data		      if splitCount > 1 then		        tempUID = splitbuf(1)		        //Time in packet is in seconds, we need to send it in microseconds		        tempTime = (val(splitbuf(2))-syncTime)*1000.0		        uids = tempUID		        		      else		        //Not a valid transponder packet we need to discard it		        if flagEnd = lenB(buffer) then		          buffer = ""		          processing = false		          return		        else		          buffer = RightB(buffer,len(buffer) - flagEnd)		          processing = false		          return		        end if		        		      end if		      		      //Clear out the processed data		      if flagEnd < lenb(buffer) then		        buffer = RightB(buffer,len(buffer) - flagEnd)		      else		        buffer = ""		      end if		      		      DetectedUIDs(uids,tempTime)		      		    case "init"		      		      		      //Check to see if we have enough data in the buffer to process		      if lenb(buffer) < 4 then		        //Not enough data to care		        processing = false		        Return		      end if		      		      //Check to see if we have a valid packet		      flagStart = InStrb(buffer, ChrB(&h53))		      flagEnd = InStrB(buffer, ChrB(&h0A))		      //If 0 is returned then we do not have a beginning of a packet, data can be discarded		      if flagStart = 0 then		        //no good data,		        //flush it all		        buffer = ""		        processing = false		        return		      ElseIf flagEnd = 0 then		        // we do not have a complete packet return and wait		        processing = false		        return		      end if		      		      //Make sure we do not have an end of a packet stuck in the buffer, if so discard that data and start over		      if flagEnd < flagStart then		        //oops we have bad data before flagstart and need to discard that data check to see if we have another end		        buffer = RightB(buffer,lenb(buffer) -flagStart + 1)		        		        flagEnd = InStrB(buffer, ChrB(&h0A))		        		        if flagEnd = 0 then		          //Not enough data to continue yet		          processing = false		          return		        end if		      end if		      		      //make sure we have a sync packet		      //If not get rid of the packet		      if buffer.midb(flagStart+1,1) <> ChrB(&h59) and flagEnd < lenB(buffer) then		        //We must have some other packet not a sync packet		        //Discard this data and continue one		        buffer = RightB(buffer,len(buffer) - flagEnd)		        processing = false		        return		      elseif buffer.midb(flagStart+1,1) <> ChrB(&h59) and flagEnd = lenB(buffer) then		        buffer = ""		        processing = false		        return		      end if		      		      //take the substring to work with		      subbuf = MidB(buffer, flagStart, flagEnd-flagStart+1)		      //Split it out		      splitbuf = split(subbuf, chrb(&h20))		      		      splitCount = UBound(splitbuf)		      		      //Check to see that we have enough elements in array, if so get the sync time		      if splitCount > 1 then		        syncTime = val(splitbuf(1))		        commandmode = "polling"		      else		        //Not a valid packet we need to discard it		        if flagEnd = lenB(buffer) then		          buffer = ""		          processing = false		          return		        else		          buffer = RightB(buffer,len(buffer) - flagEnd)		          processing = false		          return		        end if		        		      end if		      		      //Clear out the processed data		      if flagEnd < lenb(buffer) then		        buffer = RightB(buffer,len(buffer) - flagEnd)		      else		        buffer = ""		      end if		      		      		    else		      //We are getting data but no command was issued, discard data		      buffer = ""		      		    end select		    		  end if		  		  //done processing set to false		  processing = false		  		  //check to see if there is data still to process		  if lenb(buffer) > 13 then		    ReadDCDData		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadFSAlphaData()		  //Read data from the Flip Side Alpha lap counter		  		  //When the FS Alpha is in polling mode the data coming back looks like this		  // 11 00 EE 00 E2 00 10 27 72 17 00 59 18 90 50 C7 69 F9		  //Byte 1 is the packet length minus 1, 18 bytes long in this case		  //Bytes 2 - 4  are the header, always 00 EE 00, 00 is the reader address, EE is the command and the final 00 is the status		  //Bytes 5 - 16 are the EPC code E2 00 10 27 72 17 00 59 18 90 50 C7		  //Byte 17 - 18 is the checksum		  		  //Results for some tags are shorter, for example		  // 09 00 EE 00 32 39 36 00 78 E6		  //Byte 1 is the packet length minus 1, 10 bytes long in this case		  //Bytes 2 - 4  are the header, always 00 EE 00, 00 is the reader address, EE is the command and the final 00 is the status		  //Bytes 5 - 8 are the EPC code E32 39 36 00		  //Bytes 9 - 10 is the checksum		  		  dim flagStart,flagEnd as Integer = -1		  dim uids as string		  dim tempUID as string		  dim packetLength as integer		  		  //Make sure we are not already analyzing data		  if processing = false then		    //We are not currently processing data so we can begin		    processing = true		    		    //Make sure we have enough data to consider processing		    if InStrB(buffer, ChrB(&hEE)) + 4 > lenb(buffer) then		      //Not enough data bail		      processing = false		      return		    end if		    		    //check to see if we have a valid packet		    flagStart = InStrB(buffer, Chrb(&h00) + Chrb(&hEE) + Chrb(&h00)) - 1		    //if -1 was returned as flag start then we have no good data and can discard everything		    //if 0 was returned the data is still bad, the first byte of the response tells us the length so we need that.		    if flagStart < 1 then		      //flush it all		      buffer = ""		      processing = false		      return		      		    end if		    		    //We have to use the byte located at flag start to determine the length of the packet		    //The length is 1 byte more than what is reported		    packetLength = ascb(midb(buffer, flagStart, 1))		    if packetLength < 9 then		      //flush it all, bad packet		      buffer = ""		      processing = false		      return		    end if		    		    		    flagEnd = flagStart + packetLength		    		    //Make sure we have a complete packet		    if flagStart + packetLength > LenB(buffer) then		      //Not enough data, bail		      processing = false		      return		    end if		    		    //Our packet passed the basic tests so we can process this data now		    tempUID = midb(buffer, flagStart+4, packetLength - 5)		    		    //now we need to convert it to Hex		    dim hexPart as string		    dim hexString as string		    		    //for i as integer = packetLength - 5 DownTo 1		    for i as integer = 1 to packetLength - 5		      hexPart = hex(ascb(midb(tempUID,i,1)))		      if lenb(hexPart)<2 then		        hexpart="0"+hexPart		      end if		      hexString = hexString + hexPart		    next		    //Append it to the UID array used to pass to the detecteduids method		    uids = hexString		    		    //Clear out the processed data		    if flagEnd < lenb(buffer) then		      buffer = RightB(buffer, lenb(buffer) - FlagEnd)		    else		      buffer = ""		    end if		    		    //We detected a UID to call the method		    DetectedUIDS(uids,0)		    		  end if		  		  //Done processing set to false		  processing = false		  		  //Check to see if there is another packet to process		  if lenb(buffer) > 9 then		    ReadFSAlphaData		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadFSDIOData()		  //Parse incoming data from the Flip Side DIO adapter		  		  //The FSDIO adapter is a way to replace the use of a parallel port for digital inputs since they are no longer common		  //This allows the use of slot car or laser type lap timers		  //We use the digital io pins on the Arduino Uno for this project, starting at pin 2 up to pin 13		  //This hardware sends individual ID's as a single byte character, all we need to do is convert this byte to a printable string		  		  		  if processing = false then		    		    processing = true		    		    select case commandmode		      		    case "inventory", "polling"		      dim uids() as string		      		      //Just in case lets make sure we actually have some data		      if lenb(buffer) < 1 then		        //No data to check		        processing = false		        return		      end if		      		      //OK convert each byte to an ID		      for i as integer = 1 to lenb(buffer)		        uids.Append(str(ascb(midb(buffer,i,1))))		      next		      		      buffer = ""		      		      //Send the uids off to be counted		      if UBound(uids) > -1 then		        for each element as string in uids		          DetectedUIDS(element, 0)		        next		      end if		      		    else		      //Empty the buffer as we do not need to process data		      buffer = ""		      		    end select		    		  end if		  		  //We are done so set to false so processing will occur if more data comes in		  processing = false		  		  //Make sure we do not have any data left in the buffer		  if lenb(buffer) > 0 then		    ReadFSDIOData		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadGiroZData()		  //Parse incoming data from the Giro-Z lap counting hardware		  		  //The transponder packets for the Giro-Z lap counting hardware will appear like this, data is in hex		  // 33 33 D5 16 0F 00 DD 6B CC 7B BE 8B AC 9B 9A AB 83 BB 71 CB 60 DB 4D EB 3B FB 44 44		  // Bytes 1-2 are the header and are always 33 33		  // Bytes 3-6 are the time in reverse byte order		  // Bytes 7-26 are the transponder data, the amount of transponder data varies depending on the id.  The data is format as a series of increasing timer values, each pair of bytes are in reverse byte order and represents a number		  // You must look at the difference between these bytes to determine the id.  To calculate the id look at the minimal difference and calculate -41.5*ln(x) + 346		  // Round this to the nearest whole number which is the id.  It is best too look at the minimum as sometimes the packet will miss some of the timing info causing the average to be hight		  // So for the example above you would reverse the first byte pairs to get 6B DD and 7B CC, you get FEF as the difference for these, apply the above equation and you get .985 (id 1)		  // Bytes 27-28 are the end of the packet, they are always 44 44		  		  // Another example would be		  // 33 33 29 4B 0C 00 0C 6A 29 78 47 86 64 94 81 A2 9E B0 BB BE D8 CC F5 DA 12 E9 30 F7 44 44		  // In this case the bytes 7-28 are the transponder data, by calculating the minimum difference we see that the id is 6.02 (round to the nearest integer, 6)		  		  //Additionally every second the hardware will generate a timing packet that looks like this		  // 11 11 00 88 16 00		  // Bytes 1-2 are the header and are always 11 11		  // Bytes 3-6 are the time		  		  dim flagStart,flagEnd as Integer = -1		  dim numTiming as integer		  dim tempTiming() as integer		  dim highTime as integer		  dim lowTime as integer		  dim timingStart as integer		  dim timingMatches(23) as integer		  dim upperTimingLimit as integer		  dim lowerTimingLimit as integer		  dim i as integer		  dim j as integer		  dim tempDouble as double		  dim tempRound as double		  dim index as integer		  dim tempTime as integer		  dim matchThreshold as integer		  		  		  //Debugging parameters		  		  		  //Create an array of precalculated timing values to compare to		  //static timingValues(23) as integer		  //timingValues = Array(4078,3980,3886,3793,3703,3615,3529,3445,3363,3283,3204,3128,3054,2981,2910,2841,2773,2707,2643,2580,2518,2458,2400,2343)		  		  //Set the limits so we know if we might have valid data		  //We are allowing a variance of 0.002%		  upperTimingLimit = 4087		  lowerTimingLimit = 2338		  		  //Set the number of times that we have to detect the timing value in a packet to count it as a match		  matchThreshold = 5		  		  //Make sure we are not already analyzing data		  if processing = false then		    		    processing = true		    		    //Check which command type is happening to determine how to decode data		    select case commandmode		      		    case "inventory", "polling"		      		      //Check to see if we have enough data in the buffer to process		      if lenb(buffer) < 6 then		        //Not enough data to care		        processing = false		        Return		      end if		      		      //Check to see if we have a time packet		      timingStart = InStrB(buffer, ChrB(&h11) + ChrB(&h11))		      if lenb(buffer) = 6 and timingStart = 1 then		        //We have a timing packet, drop it		        buffer = ""		        processing = false		        return		      end if		      		      		      //Check to see if we have a valid packet		      flagStart = InStrb(buffer, ChrB(&h33) + ChrB(&h33))		      flagEnd = InStrB(buffer, ChrB(&h44) + ChrB(&h44)) + 1		      //If 0 is returned then we do not have a beginning of a packet, data can be discarded		      if flagStart = 0 then		        //no good data,		        //flush it all		        buffer = ""		        processing = false		        return		      ElseIf flagEnd = 0 then		        // we do not have a complete packet return and wait		        processing = false		        return		      end if		      		      //Make sure we do not have an end of a packet stuck in the buffer, if so discard that data and start over		      if flagEnd < flagStart then		        //oops we have bad data before flagstart and need to discard that data check to see if we have another end		        buffer = RightB(buffer,lenb(buffer) -flagStart + 1)		        		        flagEnd = InStrB(buffer, ChrB(&h44) + ChrB(&h44)) + 1		        		        if flagEnd = 0 then		          //Not enough data to continue yet		          processing = false		          return		        end if		      end if		      		      //make sure we have a transponder packet		      //If not get rid of the packet		      if flagEnd - flagStart < 11 and flagEnd < lenB(buffer) then		        //We must have some other packet not a transponder packet		        //Discard this data and continue one		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		        processing = false		        return		      elseif flagEnd - flagStart < 11 and flagEnd = lenB(buffer) then		        buffer = ""		        processing = false		        return		      end if		      		      //Determine how many timing values we have in the data stream		      numTiming = (FlagEnd - 8)/2		      		      //Now go through the timining values checking the difference and storing the difference		      //Since we are doing differences we iterate one less time than the total number of values but since we are starting at 0 instead of 1 we must go 2 less		      //Set tempTime high as  we are looking for the lowest number		      		      for i = 0 to numTiming - 2		        highTime = ascB(midb(buffer, flagStart + 8 + i*2)) + ascB(midb(buffer, flagStart + 9 + i*2))*256		        lowTime = ascB(midb(buffer, flagStart + 6 + i*2)) + ascB(midb(buffer, flagStart + 7 + i*2))*256		        tempTiming.Append(highTime - lowTime)		      next		      		      //We now have an array of differences, we need to analyze this for possible valid times		      //Since multiple transponders can be mixed in this data we have to analyze multiple possiblities		      //We append a few extra values so we do not have to check for the upper bound with various calculations		      tempTiming.Append(9999)		      tempTiming.Append(9999)		      tempTiming.Append(9999)		      for i = 0 to UBound(tempTiming) - 3		        tempTime = 0		        for j = 0 to 2		          tempTime = tempTime + tempTiming(i+j)		          if tempTime > upperTimingLimit then		            //No need to continue adding as we are already too high		            exit for j		          end if		          if tempTime >= lowerTimingLimit then		            //We already tested if we are too high so only need to look above the lower limit		            tempDouble = (log(tempTime) * -41.5) + 346		            tempRound = Round(tempDouble)		            if tempDouble <= tempRound + 0.2 and tempDouble >= tempRound - 0.2 then		              index = tempRound		              if index > 0 and index < 25 then		                timingMatches(index - 1) = timingMatches(index - 1) + 1		              end if		            end if		            		          end if		          		        next		      next		      		      //Clear out the processed data		      if flagEnd < lenb(buffer) then		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		      else		        buffer = ""		      end if		      		      		      //Now that we are done we need to see how many of each transponder id we got		      for i = 0 to UBound(timingMatches)		        if timingMatches(i) >= matchThreshold then		          DetectedUIDs(str(i+1),0)		        end if		      next		      		    else		      //We are getting data but no command was issued, discard data		      buffer = ""		      		    end select		    		  end if		  		  //done processing set to false		  processing = false		  		  //check to see if there is data still to process		  if lenb(buffer) > 5 then		    ReadGiroZData		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadGKA9805Data()		  //Read data from the GKA 9805 by Global KeyAccess		  		  //When the GKA 9805 is in polling mode the data coming back looks like this		  // CC FF FF 01 08 0D 09 00 9E 00 00 00 00 00 00 00 00 00 79		  //Bytes 1-5  are the header, always CC FF FF 01 08		  //Byte 6 is the status		  //Bytes 7-18 are the EPC code 09 00 9E 00 00 00 00 00 00 00 00 00		  //Byte 19 is the checksum, calculated by summing the previous bytes but rolling over at the byte level and then subtracting the result from &h100		  		  dim flagStart,flagEnd as Integer = -1		  dim uids as string		  dim tempUID as string		  		  //Make sure we are not already analyzing data		  if processing = false then		    //We are not currently processing data so we can begin		    processing = true		    		    //Make sure we have enough data ton consider processing		    if InStrB(buffer, ChrB(&hCC)) + 4 > lenb(buffer) then		      //Not enough data bail		      processing = false		      return		    end if		    		    //check to see if we have a valid packet		    flagStart = InStrB(buffer, Chrb(&hCC) + Chrb(&hFF) + Chrb(&hFF) + Chrb(&h01) + Chrb(&h08))		    flagEnd = flagStart + 18		    //if 0 was returned as flag start then we have no good data and can discard everything		    if flagStart = 0 then		      //flush it all		      buffer = ""		      processing = false		      return		      		    end if		    		    //Make sure we have a complete packet		    if flagStart + 18 > LenB(buffer) then		      //Not enough data, bail		      processing = false		      return		    end if		    		    //Our packet passed the basic tests so we can process this data now		    tempUID = midb(buffer, flagStart+6, 12)		    		    //now we need to convert it to Hex		    dim hexPart as string		    dim hexString as string		    		    for i as integer = 12 DownTo 1		      hexPart = hex(ascb(midb(tempUID,i,1)))		      if lenb(hexPart)<2 then		        hexpart="0"+hexPart		      end if		      hexString = hexString + hexPart		    next		    //Append it to the UID array used to pass to the detecteduids method		    uids = hexString		    		    //Clear out the processed data		    if flagEnd < lenb(buffer) then		      buffer = RightB(buffer, lenb(buffer) - FlagEnd)		    else		      buffer = ""		    end if		    		    //We detected a UID to call the method		    DetectedUIDS(uids,0)		    		  end if		  		  //Done processing set to false		  processing = false		  		  //Check to see if there is another packet to process		  if lenb(buffer) > 18 then		    ReadGKA9805Data		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadILapData()		  //For the I-Lap hardware there are two known response packets		  //To start the lap counter you must send the following command		  // 01 25 0D 0A		  //This initializes the lap counter into 7 digit mode		  //This will respond with a packet that looks like the following		  // 01 25 09 32 30 34 09 30 09 30 0D 0A		  		  //The breakdown is the following		  //Byte 1 is the header, 01		  //Byte 2 is the packet type, 25 (%) for an initialization packet		  //Byte 3 is a seperator character, 09 seperates fields		  //Bytes 4-6 are the decoder id in ascii, 204 in this case		  //Byte 7 is a seperator, 09		  //Byte 8 is not used set to 0 in ascii		  //Byte 9 is a seperator, 09		  //Byte 10 is not used set to 0 in ascii		  //Bytes 11 and 12 are the ending delimiter, 0D 0A is a new line character sequence		  		  //After the lap counter is initialized it will send a packet each time a car is detected		  //An example packet would look like this		  // 01 40 09 32 30 34 09 33 34 35 36 37 38 39 09 33 32 34 2E 36 32 30 0D 0A		  //The breakdown is the following		  //Byte 1 is the header, 01		  //Byte 2 is the packet type, 40 (@) for a transponder packet		  //Byte 3 is a seperator character, 09 seperates fields		  //Bytes 4-6 are the decoder id in ascii, 204 (32 30 34) in this case		  //Byte 7 is a seperator character, 09		  //Bytes 8-14 are the transponder id in ascii characters, 3456789 (33 34 35 36 37 38 39)		  //Byte 15 is a seperator character, 09		  //Bytes 16 - 22 are the time, it starts counting up when initalized, this field can vary in size, time is in the format SECS.MSS, 324.620 in this case		  //Bytes 23 and 24 are the ending delimiter, 0D 0A is a new line character		  		  // A second example would look like this		  // 01 40 09 32 30 34 09 33 31 37 34 39 36 36 09 31 32 2E 32 32 36 0D 0A		  // This has a transponder 3174966 and a time of 12.226		  		  // Third example		  // 01 40 09 32 30 34 09 37 32 35 31 33 31 38 09 34 2E 34 34 38 0D 0A		  // This has transponder 7251318 and a time of 4.448		  		  dim flagStart,flagEnd as Integer = -1		  dim uids as string		  dim subbuf as string		  dim splitbuf() as string		  dim splitCount as integer		  dim tempUID as string		  dim tempTime as double		  		  //Make sure we are not already analyzing data		  if processing = false then		    		    processing = true		    		    //Check which command type is happening to determine how to decode data		    select case commandmode		      		    case "inventory", "polling"		      		      //Check to see if we have enough data in the buffer to process		      if lenb(buffer) < 12 then		        //Not enough data to care		        processing = false		        Return		      end if		      		      //Check to see if we have a valid packet		      flagStart = InStrb(buffer, ChrB(&h01))		      flagEnd = InStrB(buffer, ChrB(&h0A))		      //If 0 is returned then we do not have a beginning of a packet, data can be discarded		      if flagStart = 0 then		        //no good data,		        //flush it all		        buffer = ""		        processing = false		        return		      ElseIf flagEnd = 0 then		        // we do not have a complete packet return and wait		        processing = false		        return		      end if		      		      //Make sure we do not have an end of a packet stuck in the buffer, if so discard that data and start over		      if flagEnd < flagStart then		        //oops we have bad data before flagstart and need to discard that data check to see if we have another end		        buffer = RightB(buffer,lenb(buffer) -flagStart + 1)		        		        flagEnd = InStrB(buffer, ChrB(&h0A))		        		        if flagEnd = 0 then		          //Not enough data to continue yet		          processing = false		          return		        end if		      end if		      		      //make sure we have a transponder packet		      //If not get rid of the packet		      if flagEnd - flagStart < 19 and flagEnd < lenB(buffer) then		        //We must have some other packet not a transponder packet		        //Discard this data and continue one		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		        processing = false		        return		      elseif flagEnd - flagStart < 19 and flagEnd = lenB(buffer) then		        buffer = ""		        processing = false		        return		      end if		      		      //take the substring to work with		      subbuf = MidB(buffer, flagStart, flagEnd-flagStart+1)		      //Split it out		      splitbuf = splitb(subbuf, chrb(&h09))		      		      splitCount = UBound(splitbuf)		      		      //Check to see that we have enough elements in array, if so then use the transponder id, otherwise discard the data		      if splitCount > 2 then		        tempUID = splitbuf(2)		        tempTime = val(splitbuf(3))*1000000		        //Make sure it is a valid UID		        if lenb(tempUID) = 7 then		          uids = tempUID		        end if		        		      else		        //Not a valid transponder packet we need to discard it		        if flagEnd = lenB(buffer) then		          buffer = ""		          processing = false		          return		        else		          buffer = RightB(buffer,lenb(buffer) - flagEnd)		          processing = false		          return		        end if		        		      end if		      		      //Clear out the processed data		      if flagEnd < lenb(buffer) then		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		      else		        buffer = ""		      end if		      		      DetectedUIDs(uids,tempTime)		      		    else		      //We are getting data but no command was issued, discard data		      buffer = ""		      		    end select		    		  end if		  		  //done processing set to false		  processing = false		  		  //check to see if there is data still to process		  if lenb(buffer) > 19 then		    ReadILapData		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadKyoshoICData()		  //First read the data in and break it apart into an array of Hex codes to work with		  		  		  dim flagStart,flagEnd,dataStart as Integer = -1		  dim packetLength as Integer = -1		  dim tempUID as string		  dim uids as string		  		  		  		  //Make sure we are not already analyzing data		  if processing = false then		    		    processing = true		    		    //Check which command type is happening to determine how to decode data		    select case commandmode		      		    case "inventory"		      		      'Example data		      'Sent 35 03 36		      'Received 5F A1 0B 2E F8 53 11 00 01 04 E0 DB		      'Header 5F A1 0B		      '3rd byte in header is length excluding Checksum, 0B, 11 bytes		      'Tag is reverse byte order E0 04 01 00 11 53 F8 2E		      'Final byte is checksum DB, XOR operation		      'With no tag recieved		      '5F A1 03 A2		      		      //We need to discard extraneous 5F characters, they get returned for each inventory command sent		      //But we do not want to discard the 5F that starts a real response with a UID so we need to wait until we have at least 2 bytes in the buffer		      if lenb(buffer) > 1 then		        if buffer.midb(1,1) = chrb(&h5F) and buffer.midb(2,1) = chrb(&h5F) then		          buffer = buffer.rightb(lenb(buffer)-1)		          processing = false		          return		        end if		        		      end if		      		      //Check to see if we have a valid packet		      flagStart = InStrb(buffer, ChrB(&h5F) + ChrB(&hA1))		      //If 0 is returned then we do not have a beginning of a packet, data can be discarded		      if flagStart = 0 then		        //no good data, flush the buffer and return		        buffer = ""		        processing = false		        return		      ElseIf lenb(buffer) < 12 + flagStart - 1 then		        // we do not have a complete packet return and wait		        return		      end if		      		      //Data begins 2 bytes after the beginnning of the packet		      dataStart=flagStart+3		      		      		      		      		      if flagStart<>-1 and packetLength=-1 then//if we have a valid command coming in, and packetLength has not been decided lets decide it.		        packetLength = ascb(buffer.midb(flagStart+2,1)) + 1//bytes 1 from the start describe the length		      end if		      		      flagEnd = flagStart + packetLength - 1		      tempUID = MidB(buffer, dataStart, 8)		      		      //Must convert the string to a readable format		      dim hexPart as string		      dim hexString as string		      		      for i as integer = 8 DownTo 1		        hexPart = hex(ascb(midb(tempUID,i,1)))		        if lenb(hexPart)<2 then		          hexpart="0"+hexPart		        end if		        hexString = hexString + hexPart		      next		      		      uids = hexString		      		      if flagEnd < lenb(buffer) then		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		      else		        buffer = ""		      end if		      		      //Clear Variables		      flagStart=-1		      flagEnd=-1		      packetLength=-1		      dataStart=-1		      tempUID=""		      //errorText.Text="Assemble Completed"		      		      DetectedUIDs(uids,0)		      		      //Fixme, need a way to silence a tag		      		      		    case "polling"		      		      //When a tag is detected it will be returned like this		      //Byte 1 is the start of the frame, always A3 for the polling method		      //Byte 2 is the length of the frame INCLUDING checksum		      //Bytes 3-6 are the data from block 2 of the tag in reverse byte order		      //Byte 7 is the number of times the tag was detected		      //Bytes 8-10 are unknown		      //Byte 11 is the checksum		      		      //An example response that has a tag of AA BB CC DD would look like this		      //A3 0B DD CC BB AA E1 01 00 00 48		      		      //If Bytes 3-6 are 00 00 00 00 then the tag is invalid		      		      //Check to see if we have a valid packet		      flagStart = InStrb(buffer, ChrB(&hA3) + ChrB(&h0B))		      //If 0 is returned then we do not have a beginning of a packet, data can be discarded		      if flagStart = 0 then		        //no good data, flush the buffer and return		        buffer = ""		        processing = false		        return		      ElseIf lenb(buffer) < 11 + flagStart - 1 then		        // we do not have a complete packet return and wait		        return		      end if		      		      //Data begins 2 bytes after the beginnning of the packet		      dataStart=flagStart+2		      		      		      		      		      if flagStart<>-1 and packetLength=-1 then//if we have a valid command coming in, and packetLength has not been decided lets decide it.		        packetLength = ascb(buffer.midb(flagStart+1,1))//bytes 1 from the start describe the length		      end if		      		      flagEnd = flagStart + packetLength - 1		      tempUID = MidB(buffer, dataStart, 4)		      		      //Must convert the string to a readable format		      dim hexPart as string		      dim hexString as string		      		      for i as integer = 4 DownTo 1		        hexPart = hex(ascb(midb(tempUID,i,1)))		        if lenb(hexPart)<2 then		          hexpart="0"+hexPart		        end if		        hexString = hexString + hexPart		      next		      		      uids = hexString		      		      if flagEnd < lenb(buffer) then		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		      else		        buffer = ""		      end if		      		      //Clear Variables		      flagStart=-1		      flagEnd=-1		      packetLength=-1		      dataStart=-1		      tempUID=""		      //errorText.Text="Assemble Completed"		      		      DetectedUIDs(uids,0)		      		      //Fixme, need a way to silence a tag		      		    else		      //We are getting data but no command was issued, discard data		      ReDim assembledhex(-1)		      buffer = ""		      		      		    end select		    		  end if		  		  //done processing set to false		  processing = false		  		  //check to see if there is data still to process		  if lenb(buffer) > 9 then		    ReadKyoshoICData		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadLapZData()		  //LapZ commands and responses start with # and end with $		  //The commands always consist of ascii characters		  //To start the lap counter you must send the following command		  // 23 53 24		  //This is #S$ in ascii		  //End stop the lap counter you send this command		  // 23 46 53		  //This is #F$ in ascii		  		  //During a race there are 2 packet types that will be received, a car packet and a clock packet		  		  //A car packet can look like this #P220001AB$		  //The breakdown is the following		  //Byte 1 is the header, # or hex 23		  //Byte 2 identifies the packet type, P or hex 50, which means it is a car packet		  //Bytes 3-4 are the car id, the id is in ascii text but represents a hex number, only 01-FF are valid, in this example it is car 13 or 0D as the hex		  //Bytes 5-10 is the number of milliseconds passed in the race, in ascii hex, so 0001AB or .427 seconds		  //Byte 11 is the end, $, or hex 24		  		  //The other packet type we get is a clock update, an example could be #U00F123$, they come in about every 7 seconds		  //The breakdown is the following		  //Byte 1 is the header, # or hex 23		  //Byte 2 identifies the packet type, U or hex 55, which means it is a clock packet		  //Bytes 3-8 is the number of milliseconds passed in the race, in ascii hex, so 00F123 or 61.731 seconds		  //Byte 9 is the end, $, or hex 24		  		  dim flagStart,flagEnd as Integer = -1		  dim uids as string		  dim subbuf as string		  dim tempTime as double		  dim timeString as string		  		  //Make sure we are not already analyzing data		  if processing = false then		    		    processing = true		    		    //Check which command type is happening to determine how to decode data		    select case commandmode		      		    case "inventory", "polling"		      		      //Check to see if we have enough data in the buffer to process		      if lenb(buffer) < 9 then		        //Not enough data to care		        processing = false		        Return		      end if		      		      //Check to see if we have a valid packet		      flagStart = InStrb(buffer, ChrB(&h23))		      flagEnd = InStrB(buffer, ChrB(&h24))		      //If 0 is returned then we do not have a beginning of a packet, data can be discarded		      if flagStart = 0 then		        //no good data,		        //flush it all		        buffer = ""		        processing = false		        return		      ElseIf flagEnd = 0 then		        // we do not have a complete packet return and wait		        processing = false		        return		      end if		      		      //Make sure we do not have an end of a packet stuck in the buffer, if so discard that data and start over		      if flagEnd < flagStart then		        //oops we have bad data before flagstart and need to discard that data check to see if we have another end		        buffer = RightB(buffer,lenb(buffer) -flagStart + 1)		        		        flagEnd = InStrB(buffer, ChrB(&h24))		        		        if flagEnd = 0 then		          //Not enough data to continue yet		          processing = false		          return		        end if		      end if		      		      //make sure we have a transponder packet		      //If not get rid of the packet		      if flagEnd - flagStart < 10 and flagEnd < lenB(buffer) then		        //We must have some other packet not a transponder packet		        //Discard this data and continue one		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		        processing = false		        ReadLapZData		        return		      elseif flagEnd - flagStart < 10 and flagEnd = lenB(buffer) then		        buffer = ""		        processing = false		        return		      end if		      		      //take the substring to work with		      subbuf = MidB(buffer, flagStart, flagEnd-flagStart+1)		      		      //Get bytes 3 and 4 for the UID		      uids = MidB(subbuf, 3, 2)		      		      //Get the time, which is bytes 5 to 1 - end		      timeString = MidB(subbuf, 5, len(subbuf) - 1)		      		      //Time is in an ascii encoded hex milliseconds, we must convert this to microseconds double		      tempTime = val("&h" + timeString) * 1000		      		      		      //Clear out the processed data		      if flagEnd < lenb(buffer) then		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		      else		        buffer = ""		      end if		      		      DetectedUIDs(uids,tempTime)		      		    else		      //We are getting data but no command was issued, discard data		      buffer = ""		      		    end select		    		  end if		  		  //done processing set to false		  processing = false		  		  //check to see if there is data still to process		  if lenb(buffer) > 8 then		    ReadLapZData		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadRobitronicData()		  dim flagStart,flagEnd,dataStart as Integer = -1		  dim packetLength as Integer = -1		  dim tempUID as string		  dim uids as string		  dim timeStart as Integer = 0		  dim timepacket as boolean = false		  dim startBufferSize, endBufferSize as integer		  dim signalStrength as string		  dim signalHits as string		  		  startBufferSize = 0		  endBufferSize = 0		  //G_LoggingG_Logging.add("SerialLapCounters.ReadRobitronicData","Processing pre check indicates " + str(processing) + ", command mode is " + commandmode + ", buffer size is " + str(lenb(buffer)))		  //G_LoggingG_Logging.add("SerialLapCounters.ReadRobitronicData","buffer data = " + convertToHex(buffer))		  		  //Make sure we are not already analyzing data		  if processing = false then		    		    processing = true		    		    //Check which command type is happening to determine how to decode data		    select case commandmode		      		    case "polling"		      //The Robitronic hardware will send back 2 packet types, either a plain timestamp or a car id with a timestamp		      //We can discard plain timestamp packets		      //Before the lap counter starts transmitting data you must initialize it with a 03 B9 01 of which it will respond with a 00		      		      		      //When a car is detected it will be returned like this		      //Byte 1 is the length of the packet, 0D for a car detected		      //Byte 2 is the length of the frame INCLUDING checksum		      //Byte 3 is the type of packet, 84 for a car id packet		      //Byte 4-5 represents the UID in reverse byte order		      //Byte 6-7 are unknown, 00 in this example		      //Byte 8-11 are the seconds in thousandths of a second in reverse byte order		      //Byte 12 is the number of hits detected of the transponder		      //Byte 13 is the signal strenght of the transponder.		      		      //An example response that has a tag of 08 1E would look like this		      //0D BD 84 1E 08 00 00 E7 36 00 00 55 F9		      		      		      //Every second the lap counter will also send out a time packet, these packets can be discarded		      //The packet looks like this		      //Byte 1 is the length of the packet 0B in the case of just a time stamp		      //Byte 2 is a checksum		      //Byte 3 is the packet type, 83 in the case of time stamp only		      //Byte 4-7 is the seconds in reverse byte order in thousandths of a second		      //Bytes 8-11 are unknown but in example were always 14 D0 01 02		      		      //An example of the time packet looks like this		      //0B 5C 83 9B 3A 00 00 14 D0 01 02		      		      //Remove any extra data at the beginning		      		      //make sure we have enough data to try even processing the packet		      if lenb(buffer) < 11 then		        //G_LoggingG_Logging.add("SerialLapCounters.ReadRobitronicData","Less than 11 bytes in buffer, " + str(lenb(buffer)) + " bytes")		        processing = false		        Return		      end if		      		      while lenb(buffer) > 10		        //Record how much data was in the buffer when we started		        //We will compare this at the end to determine if we need to continue processing		        startBufferSize = lenb(buffer)		        		        for j as integer = 1 to lenb(buffer) - 2		          if buffer.midb(j,1) = ChrB(&h0B) and buffer.midb(j+2,1) = ChrB(&h83) then		            //We have a time packet, we can discard this		            timeStart = j		            timepacket = true		            //G_LoggingG_Logging.add("SerialLapCounters.ReadRobitronicData","Time packet discarded")		            exit for j		          elseif buffer.midb(j,1) = ChrB(&h0D) and buffer.midb(j+2,1) = ChrB(&h84) then		            //We have the beginning of a car packet		            flagStart = j		            exit for j		          end if		          flagstart = 0		        next		        		        if timepacket = true then		          //We have a time packet, we need to make sure we have all of the packet before discarding it		          if lenb(buffer) < 10 + timeStart - 1 then		            //not enough data return		            //G_LoggingG_Logging.add("SerialLapCounters.ReadRobitronicData","Less than 11 bytes in buffer after finding time packet, " + str(lenb(buffer)) + " bytes")		            processing = false		            return		          end if		          		          //enough data so we can discard the time packet		          dim length as integer		          length = lenb(buffer) - 11 - timeStart + 1		          if length < 1 then		            buffer = ""		          else		            buffer = buffer.rightb(length)		          end if		          		        else		          		          //If 0 is returned then we do not have a beginning of a packet, data can be discarded		          if flagStart = 0 then		            //no good data, flush the buffer and return		            //Must keep the last 2 characters just in case, it could be the start of the next packet		            //G_LoggingG_Logging.add("SerialLapCounters.ReadRobitronicData","No good data, delete all but last 2 bytes")		            buffer = buffer.Rightb(2)		            processing = false		            return		          ElseIf lenb(buffer) < 13 + flagStart - 1 then		            // we do not have a complete packet return and wait		            //G_LoggingG_Logging.add("SerialLapCounters.ReadRobitronicData","Incomplete packet, return and wait")		            processing = false		            return		          end if		          		          //Data begins 3 bytes after the beginnning of the packet		          dataStart=flagStart+3		          		          		          if flagStart<>-1 and packetLength=-1 then//if we have a valid command coming in, and packetLength has not been decided lets decide it.		            packetLength = ascb(buffer.midb(flagStart,1))//bytes 1 from the start describe the length		          end if		          		          flagEnd = flagStart + packetLength - 1		          tempUID = MidB(buffer, dataStart, 2)		          		          //Must convert the string to a readable format		          dim hexPart as string		          dim hexString as string		          		          for i as integer = 2 DownTo 1		            hexPart = hex(ascb(midb(tempUID,i,1)))		            if lenb(hexPart)<2 then		              hexpart="0"+hexPart		            end if		            hexString = hexString + hexPart		          next		          		          uids = hexString		          		          //Get the time from the packet		          dim packetTime as double		          //The time is in reverse byte order and in thousandths of a second, we need Microseconds		          packetTime = (ascB(midb(buffer, dataStart + 4,1)) + ascB(midb(buffer, dataStart + 5,1))*256 + ascB(midb(buffer, dataStart + 6,1))*256*256 + ascB(midb(buffer, dataStart + 7,1))*256*256*256)*1000		          		          //Get the hits and signal strength from the packet		          signalHits = hex(ascB(midb(buffer, dataStart + 8,1)))		          signalStrength = hex(ascB(midb(buffer, dataStart + 9,1)))		          		          if flagEnd < lenb(buffer) then		            buffer = RightB(buffer,lenb(buffer) - flagEnd)		          else		            buffer = ""		          end if		          		          //Clear Variables		          flagStart=-1		          timeStart=-1		          timepacket=false		          flagEnd=-1		          packetLength=-1		          dataStart=-1		          tempUID=""		          //errorText.Text="Assemble Completed"		          		          		          //G_LoggingG_Logging.add("SerialLapCounters.ReadRobitronicData","Detected UID " + uids)		          //G_LoggingG_Logging.add("SerialLapCounters.ReadRobitronicData",uids + " signal strength " + signalStrength + " hits " + signalHits)		          DetectedUIDs(uids, packetTime)		          		        end if		        		        endBufferSize = lenb(buffer)		        		        //Check to see if we need to continue		        //if no data was processed then no reason to continue as an infinite loop may result		        if startBufferSize <> endBufferSize then		          if lenb(buffer) > 10 then		            //G_Logging.add("SerialLapCounters.ReadRobitronicData","Greater than 10 bytes remain, currently " + str(lenb(buffer)) + " bytes remain, processing = " + str(processing))		            		          end if		        else		          //G_LoggingG_Logging.add("SerialLapCounters.ReadRobitronicData","No data was processed in the last pass, return and wait for data")		          processing = false		          return		        end if		        		        		      wend		      		    else		      //We are getting data but no command was issued, discard data		      ReDim assembledhex(-1)		      buffer = ""		      		    end select		    		    //done processing set to false		    processing = false		    		  end if		  		  		  //check to see if there is data still to process		  //if lenb(buffer) > 10 then		  //G_Logging.add("SerialLapCounters.ReadRobitronicData","Greater than 10 bytes remain, currently " + str(lenb(buffer)) + " bytes remain, processing = " + str(processing))		  		  //ReadRobitronicData		  //end if		  		  //G_Logging.add("SerialLapCounters.ReadRobitronicData","Method completed")		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadS6350Data()		  //Method to read ISO15693 data from a TI S6350		  		  dim rawbytes as string = me.ReadAll		  dim hexCode as string		  dim HexCommandCount as Integer		  dim flagStart,flagEnd,dataStart as Integer = -1		  dim packetLength as Integer = -1		  dim temp as string		  dim tempUID as string		  dim uids as string		  dim byteCount as integer		  		  hexCode = convertToHex(rawbytes)		  		  //Fill the array with the hex commands as they come in~		  HexCommandCount = countfieldsb(hexCode," ")		  for i as Integer=1 to HexCommandCount		    assembledHex.Append nthfieldb(hexCode," ",i)		  next		  		  'Byte 1 is the Start of Frame, always 01		  'Byte 2 and 3 is the length of the command including the 2 byte check sum that is added to the end, Least Significant Byte first		  'Byte 4 and 5 is the node address, leave at 00 as we do not reference nodes		  'Byte 6 is the command flags, no flags present		  'Byte 7 is the command, &h60 means it is an ISO15693 command which will be in the data portion of the packet		  'Bytes 8&9 are ISO settings.		  'Bytes '10+n' is the data with the UIDs		  'Last 2 Bytes are the checksum		  		  //Sample Response with 4 UIDs.		  //01 35 00 00 00 00 60 41 82 00 00 00 00 80 14 C0 12 00 00 07 E0 00 00 B6 E7 53 13 00 00 07 E0 00 00 79 14 C0 12 00 00 07 E0 00 00 7F 14 C0 12 00 00 07 E0 C6 39		  		  //Data may come in however at random intervals, therefor, a character by character analysis method has been put into place below		  		  for i as Integer=0 to UBound(assembledHex)		    //infoText.Text="i="+str(i)+"    UBound(assembledHex)="+str(UBound(assembledHex))		    if assembledHex(i)="01" then		      if ubound(assembledHex)>=(i+6) then//must be enough data so far so that we can even do the check at i+6		        if assembledHex(i+6)="60" then		          flagStart=i//valid command found, a 01 followed by 6 bytes and a 60 ISO command doesn't happen by chance.		          dataStart=i+11//11 ahead is where the data starts~		          //errorText.Text="Data Points Found"		        ElseIf assembledhex(i+6)="F0" then		          //We have a version packet and need to act accordingly		          if UBound(assembledhex)>=(i+11) then		            //we have enough data to get the version number		            hardwareversion = assembledhex(i+9)		            ReaderVersion(hardwaretype, assembledhex(i+9))		            		            //Erase this section now		            for m as Integer=1 to i + 11		              assembledHex.Remove(0)//keeps removing until it's gotten to the packetLength, leaving just anything else that may be there for analysis next round or perhaps this round still.		            next		            		          end if		          		        end if		      else		        Return//no point continuing on, we obviously don't have the rest of what we need yet to bother checking packetLengths yet.		      end if		    end if		    		    if flagStart<>-1 and packetLength=-1 then//if we have a valid command coming in, and packetLength has not been decided lets decide it.		      packetLength = val("&h" +assembledHex(flagStart+1))+val("&h"+assembledHex(flagStart+2))//bytes 2 and 3 from the start describe the length~, so start+1, start+2		      //errorText.Text="Packet Length Found"		    end if		    		    if flagStart<>-1 then		      temp=temp+assembledHex(i)+" "		      //revisedResField.Text=temp		      //infoText.Text="i="+str(i)+"   flagstart="+str(flagStart)+"    packetLength="+str(packetLength)		    end if		    //MsgBox "i="+str(i)+endOfLine+endOfLine+" flagStart="+str(flagStart)+endofLine+"abs(i-flagStart)+1="+str(abs(i-flagStart)+1)+endOfLine+"Packet Length="+str(packetLength)		    if abs(i-flagstart)+1=packetLength then		      flagEnd=i		      tempUID=""		      //MsgBox "Packet Length Verified (Packet Below)"+EndOfLine+EndOfLine+temp		      		      //Do stuff to get UID here, -2 on flagEnd because we ignore checksum.		      for k as Integer=(flagEnd-2) downto dataStart		        byteCount=byteCount+1		        tempUID=tempUID+assembledHex(k)		        if byteCount=8 then		          //MsgBox "UID="+tempUID		          uids = tempUID		          //Got a UID send it		          DetectedUIDs(uids,0)		          		          byteCount=0		          tempUID=""		          if k-1>dataStart then		            k=k-2//skip 2 positions now, the third will be where we start again correctly when loop comes around~		          end if		        end if		      next		      		      //Erase this section now		      for  k as Integer=1 to flagstart + packetLength		        assembledHex.Remove(0)//keeps removing until it's gotten to the packetLength, leaving just anything else that may be there for analysis next round or perhaps this round still.		      next		      		      temp=""		      for k as Integer=0 to UBound(assembledHex)		        temp=temp+assembledHex(k)		      next		      //MsgBox "assembledHex Test="+EndOfLine+EndOfLine+temp		      		      //Clear Variables		      flagStart=-1		      flagEnd=-1		      packetLength=-1		      dataStart=-1		      temp=""		      tempUID=""		      //errorText.Text="Assemble Completed"		    end if		  next		  		  		  		  //Sloppy way of silencing tags to speed up reads		  if lenb(rawbytes) > 22 then		    silenceTag(midb(rawbytes,14,8))		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadTrackmateData()		  //For the Trackmate hardware there are two known response packets		  //To start the lap counter timer you must send the following command		  // 01 3F 2C 32 30 32 2C 30 2C 31 31 2C 0D 0A		  //Each packet ends with a Control Line Feed, 0D 0A		  		  //Two types of packets are sent from the lap counter, one is a time packet sent periodically and the other is a transponder packet		  //All packets start with 01 and end with 0D 0A		  		  //The time packet will have byte 2 set to 23, the # character		  		  //The transponder packet with have byte 2 set to 40, the @ character		  //The fields in the transponder packet are seperated by 09, the Tab character		  //Field 1 is the header, 01 40		  //Field 2 is unknown		  //Field 3 is the transponder number		  //Field 4 is the time stamp, convert to a number and multiply by 1000 to get the time in milliseconds		  //Field 5 is the number of hits the transponder had		  		  dim flagStart,flagEnd as Integer = -1		  dim uids as string		  dim subbuf as string		  dim splitbuf() as string		  dim splitCount as integer		  dim tempUID as string		  dim tempTime as double		  		  //Make sure we are not already analyzing data		  if processing = false then		    		    processing = true		    		    //Check which command type is happening to determine how to decode data		    select case commandmode		      		    case "inventory", "polling"		      		      //Check to see if we have enough data in the buffer to process		      if lenb(buffer) < 4 then		        //Not enough data to care		        processing = false		        Return		      end if		      		      //Check to see if we have a valid packet		      flagStart = InStrb(buffer, ChrB(&h01))		      flagEnd = InStrB(buffer, ChrB(&h0A))		      //If 0 is returned then we do not have a beginning of a packet, data can be discarded		      if flagStart = 0 then		        //no good data,		        //flush it all		        buffer = ""		        processing = false		        return		      ElseIf flagEnd = 0 then		        // we do not have a complete packet return and wait		        processing = false		        return		      end if		      		      //Make sure we do not have an end of a packet stuck in the buffer, if so discard that data and start over		      if flagEnd < flagStart then		        //oops we have bad data before flagstart and need to discard that data check to see if we have another end		        buffer = RightB(buffer,lenb(buffer) -flagStart + 1)		        		        flagEnd = InStrB(buffer, ChrB(&h0A))		        		        if flagEnd = 0 then		          //Not enough data to continue yet		          processing = false		          return		        end if		      end if		      		      //make sure we have a transponder packet		      //If not get rid of the packet		      if buffer.midb(flagStart+1,1) <> "@" and flagEnd < lenB(buffer) then		        //We must have some other packet not a transponder packet		        //Discard this data and continue one		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		        processing = false		        return		      elseif buffer.midb(flagStart+1,1) <> "@" and flagEnd = lenB(buffer) then		        buffer = ""		        processing = false		        return		      end if		      		      //take the substring to work with		      subbuf = MidB(buffer, flagStart, flagEnd-flagStart+1)		      //Split it out		      splitbuf = splitb(subbuf, chrb(&h09))		      		      splitCount = UBound(splitbuf)		      		      //Check to see that we have enough elements in array, if so then use the transponder id, otherwise discard the data		      if splitCount > 4 then		        tempUID = splitbuf(3)		        //Time in packet is in seconds, we need to send it in microseconds		        tempTime = val(splitbuf(4))*1000000.0		        uids = tempUID		        		      else		        //Not a valid transponder packet we need to discard it		        if flagEnd = lenB(buffer) then		          buffer = ""		          processing = false		          return		        else		          buffer = RightB(buffer,lenb(buffer) - flagEnd)		          processing = false		          return		        end if		        		      end if		      		      //Clear out the processed data		      if flagEnd < lenb(buffer) then		        buffer = RightB(buffer,lenb(buffer) - flagEnd)		      else		        buffer = ""		      end if		      		      DetectedUIDs(uids,tempTime)		      		    else		      //We are getting data but no command was issued, discard data		      buffer = ""		      		    end select		    		  end if		  		  //done processing set to false		  processing = false		  		  //check to see if there is data still to process		  if lenb(buffer) > 15 then		    ReadTrackmateData		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ReadWanhaRacingData()		  //For the custom 7960 EVM hardware the data is sent in ASCII enclosed in []		  //This hardware automatically starts polling when the COM Port is opened and sends detected UIDS for ISO15693 tags		  //An example response would look like this		  //[E0070000145931D1]		  //The UID from this example is E0070000145931D1		  //The packets are always the same size as UID's are always 8 bytes long		  		  dim flagStart,flagEnd as Integer = -1		  dim uids as string		  dim tempUID as string		  		  //Make sure we are not already analyzing data		  if processing = false then		    //We are not currently processing data so we can begin		    processing = true		    		    //check to see if we have a valid packet		    flagStart = InStrB(buffer, Chrb(&h5B))		    flagEnd = InStrB(buffer, ChrB(&h5D))		    //if 0 was returned as flag start then we have no good data and can discard everything		    if flagStart = 0 then		      //flush it all		      buffer = ""		      processing = false		      return		    elseif flagEnd = 0 then		      //We do not have an end of the packet, return and wait		      processing = false		      return		    end if		    		    //Now check to see if the packet size is correct		    if flagEnd - flagStart < 17 then		      //Some how the packet is too small, discard everything up to flagEnd		      if flagEnd < lenb(buffer) then		        //we need to keep the data after the the flag end just in case		        buffer = RightB(buffer,lenb(buffer) - FlagEnd)		        processing = false		        //Go ahead and try again just in case		        ReadWanhaRacingData		        return		      else		        //We can get rid of it all and be done for now		        buffer = ""		        processing = false		        return		      end if		      		    ElseIf flagEnd - flagStart > 17 then		      //We ended up with a packet that is too large, discard data up to flagStart and start over		      buffer = RightB(buffer,lenb(buffer) - FlagStart)		      processing = false		      ReadWanhaRacingData		      return		    end if		    		    //Our packet passed the basic tests so we can process this data now		    tempUID = midb(buffer, flagStart+1, 16)		    //Append it to the UID array used to pass to the detecteduids method		    uids = tempUID		    		    //Clear out the processed data		    if flagEnd < lenb(buffer) then		      buffer = RightB(buffer, lenb(buffer) - FlagEnd)		    else		      buffer = ""		    end if		    		    //We detected a UID to call the method		    DetectedUIDS(uids,0)		    		  end if		  		  //Done processing set to false		  processing = false		  		  //Check to see if there is another packet to process		  if lenb(buffer) > 17 then		    ReadWanhaRacingData		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub resetTimer()		  //This method is used for hardware that has a built in timer		  //These hardware types send back a lap time along with the racer id that can be used instead of the computer timer		  		  dim sendstring as string		  		  select case hardwaretype		    		  case "Robitronic"		    		    //Clear the buffer		    buffer = ""		    //Set the command mode so dataavailable event knows what to do		    commandmode = "polling"		    //set command to send		    sendstring = ChrB(&h03) + ChrB(&hB0) + ChrB(&h02)		    //Send command		    me.Write(sendstring)		    		  case "I-Lap"		    		    //Clear the buffer		    buffer = ""		    //Set the mode for decoding data		    commandmode = "polling"		    //start polling by initializing		    sendstring = ChrB(&h01) + ChrB(&h25) + ChrB(&h0D) + ChrB(&h0A)		    me.Write(sendstring)		    		  case "Trackmate"		    		    //Clear the buffer		    buffer = ""		    //Set the mode for decoding data		    commandmode = "polling"		    //start polling by initializing		    sendstring = ChrB(&h01) + ChrB(&h3F) + ChrB(&h2C) + ChrB(&h32) + ChrB(&h30) + ChrB(&h32) + ChrB(&h2C) + ChrB(&h30) + ChrB(&h2C) + ChrB(&h31) + ChrB(&h31) + ChrB(&h2C) + ChrB(&h0D) + ChrB(&h0A)		    me.Write(sendstring)		    		  case "AMBrc"		    //Clear the buffer		    buffer = ""		    //Set the mode for decoding data		    commandmode = "polling"		    //start polling by initializing		    sendstring = ChrB(&h01) + ChrB(&h3F) + ChrB(&h2C) + decoderID + ChrB(&h2C) + ChrB(&h30) + ChrB(&h2C) + ChrB(&h31) + ChrB(&h31) + ChrB(&h2C) + ChrB(&h0D) + ChrB(&h0A)		    me.Write(sendstring)		    		  case "DCD TimeR"		    commandmode = "init"		    sendstring = ChrB(&h31) + ChrB(&h0D)		    me.Write(sendstring)		    		  case "LapZ"		    //Clear the buffer		    buffer = ""		    //Set the mode for decoding data		    commandmode = "polling"		    //Start current race		    sendstring = ChrB(&h23) + ChrB(&h53) + ChrB(&h24)		    me.Write(sendstring)		    		  case "Cano"		    //Clear the buffer		    buffer = ""		    //Set the mode for decoding data		    commandmode = "polling"		    //Reset the timer		    sendstring = ChrB(&h00)		    me.Write(sendstring)		    		  end select		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function selfOpen(port as SerialPort, type as String) As boolean		  //This method will set the hardware settings open the port send any configuration string the hardware needs		  		  dim status as boolean		  status = false		  		  //Check to see if we got a type		  if Type = "" then		    return status		  else		    //We can define the hardware type so processing knows what to do		    hardwaretype = type		  end if		  		  //Check to see if we got a valid serial port		  if port <> Nil then		    //Nothing to do then		  else		    //invalid port, return		    return status		  end if		  		  //Now we can set the hardware settings		  Select Case hardwaretype		    		  Case "CoreSpeedway","CoreSpeedway i166"		    me.Baud = 57600		  Case "AMB20"		    me.Baud = 9600		  Case "Kyosho IC"		    me.Baud = 38400		  Case "Robitronic"		    me.Baud = 38400		  Case "I-Lap"		    me.Baud = 9600		  Case "WanhaRacing"		    me.Baud = 115200		  Case "GKA9805"		    me.Baud = 9600		  Case "GiroZ USB"		    me.Baud = 115200		  Case "Trackmate"		    me.Baud = 9600		  Case "AMBrc"		    me.Baud = 9600		  Case "Flip Side Dio"		    me.Baud = 115200		  Case "DCD TimeR"		    me.Baud = 115200		  Case "LapZ"		    me.Baud = 19200		  Case "Flip Side Alpha"		    me.Baud = 57600		  Case "Cano"		    me.Baud = 115200		    		  end Select		  		  //We should try to open the port		  me.SerialPort = port		  		  //Check to see if we can open the port		  if not me.Open then		    return status		  else		    status = true		  end if		  		  //With a valid open serial port we can now send any initial command needed		  		  Select Case hardwaretype		    		  Case "CoreSpeedway","CoreSpeedway i166"		    me.Write(ChrB(&h01) + ChrB(&h09) + ChrB(&h00) + ChrB(&h00) + ChrB(&h00) + ChrB(&h00) + ChrB(&hF0) + ChrB(&hF8) + ChrB(&h07))		  Case "Kyosho IC"		    polling(true)		  Case "Robitronic"		    polling(true)		  Case "I-Lap"		    polling(true)		  Case "GKA9805"		    polling(true)		  Case "GiroZ USB"		    polling(true)		  Case "Trackmate"		    polling(true)		  Case "AMBrc"		    //Send a blank command to get the decoder id		    commandmode = "init"		    me.Write(ChrB(&h01) + ChrB(&h0D) + ChrB(&h0A))		    me.XmitWait		    me.Write(ChrB(&h01) + ChrB(&h0D) + ChrB(&h0A))		    		  Case "Flip Side Dio"		    polling(true)		    me.lightState("stop")		  Case "DCD TimeR"		    polling(true)		  Case "LapZ"		    polling(true)		  Case "Flip Side Alpha"		    polling(true)		  Case "Cano"		    polling(true)		    		  end select		  		  return status		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub silenceTag(UID as string)		  'If we detect hardware revision 09 then do not do a slicence		  'hardware 09 is based on the Infinity 166 module that locks up if we communicate too quickly to it		  		  if hardwareversion <> "09" then		    		    'The UID passed must be a string in the reverse byte order that it is recieved in		    'the string assemled by this can be sent directly to the serial port to silence the given RFID tag		    dim silencecommand as string		    		    'Everything but checksum, portion before UID is the ISO15693 silence command for a TI S6350		    'Byte 1 is the Start of Frame, always 01		    'Byte 2 and 3 is the length of the command including the 2 byte check sum that is added to the end, Least Significant Byte first		    'Byte 4 and 5 is the node address, leave at 00 as we do not reference nodes		    'Byte 6 is the command flags, no flags present		    'Byte 7 is the command, &h60 means it is an ISO15693 command which will be in the data portion of the packet		    'Byte 8 is the config byte for the reader, &h11 means 100% modulation and 1/4 data mode		    'Byte 9 is the ISO15693 command flags, &h23 means 2 sub carriers, high data rate, and address flag is set		    'Byte 10 is the ISO15693 command, &h02 means be quiet		    'Byte 11-18 are the UID that needs to shut up		    'Byte 19 and 20 are the checksum that is added later		    silencecommand = ChrB(&h01) + ChrB(&h14) + ChrB(&h00) + ChrB(&h00) + ChrB(&h00) + ChrB(&h00) + ChrB(&h60) + ChrB(&h11) + ChrB(&h23) + ChrB(&h02) + UID		    		    'checksum the string and add it to it		    silencecommand = silencecommand + tiChecksum(silencecommand)		    		    'send the command to silence the tag		    me.Write(silencecommand)		    		  end if		  		  return		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function tiChecksum(data as string) As string		  'This is to calculate the checksum used by the TI S6350		  'checksum returns a 2 byte string		  'first byte is the XOR of the string		  'second byte is the XOR of &hFF and the first byte		  		  dim checksum as string		  dim xornumber1 as integer		  dim xornumber2 as integer		  		  'Do a XOR of all the bytes of the string for byte 1 of the checksum		  'Do not worry about xornumber having a zero initially, this does not impact the XOR operation		  for i as Integer=1 to lenb(data)		    xornumber1 = xornumber1 xor ascB(midb(data,i,1))		  next		  		  'calculates byte 2 of the checksum		  xornumber2 = &hFF xor xornumber1		  		  'put the two together for the complete checksum		  checksum = chrB(xornumber1) + chrB(xornumber2)		  		  return checksum		  		End Function	#tag EndMethod	#tag Hook, Flags = &h0		Event DetectedUIDs(uids as string, times as double)	#tag EndHook	#tag Hook, Flags = &h0		Event ReaderVersion(type as string, version as String)	#tag EndHook	#tag Note, Name = Documentation		This class is being created to handle multiple types of serial based lap counters				The DetectedUIDs Event Defintion should be triggered when a UID is detected in the DataAvailable event				the buffer property is where any data from the dataavailable event is added.  This is done just in case the event fires before we get a whole packet of information.				hardwaretype must be defined, if it is not then nothing will happen.  Data will just be discarded.		     Robitronic is a valid hardware type		     CoreSpeedway is a valid hardwaretype		     Kyosho IC is a valid hardwaretype		     I-Lap is a valid hardware type		     WanhaRacing is a valid hardware type		     Trackmate is a valid hardware type				Kyosho IC lap counter communicates at 38400 baud, with default serial settings (8 data bits, no parity, 1 stop bit, no XON, no CTS, no DTR needed but can be used)				There are 2 CoreSpeedway hardware types known.  The first is based on the TI S6350 module and can be polled every 10ms, the second is based on the Infinity 166 module and can only be polled every 20ms.				I-Lap lap counter runs at 9600 baud				WanhaRacing runs at 115200 and is based on the TRF7960EVM with custom firmware to just poll for RFID's				GKA9805 runs as 9600 baud, it is a UHF RFID reader from Global KeyAccess				Trackmate runs at 9600 baud, it is based on the AMBrc protocol				AMBrc runs at 9600 baud				Flip Side Dio runs at 115200 baud.  This is based on the Arduino Uno and send single characters representing which pin is detected.				DCD TimeR runs at 115200 baud, it communicates via Bluetooth SPP	#tag EndNote	#tag Note, Name = LICENSE		Copyright 2008 Jeremy Auten				This file is part of Flip Side Racing Software.				Flip Side Racing Software is free software: you can redistribute it and/or modify		it under the terms of the GNU General Public License as published by		the Free Software Foundation, either version 3 of the License, or		(at your option) any later version.				Flip Side Racing Software is distributed in the hope that it will be useful,		but WITHOUT ANY WARRANTY; without even the implied warranty of		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the		GNU General Public License for more details.				You should have received a copy of the GNU General Public License		along with Flip Side Racing Software.  If not, see <http://www.gnu.org/licenses/>.	#tag EndNote	#tag Property, Flags = &h21		Private assembledhex() As string	#tag EndProperty	#tag Property, Flags = &h21		Private buffer As string	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			used to determine how data should be decoded		#tag EndNote		commandmode As String = "none"	#tag EndProperty	#tag Property, Flags = &h21		Private decoderID As String = "000"	#tag EndProperty	#tag Property, Flags = &h0		hardwaretype As String	#tag EndProperty	#tag Property, Flags = &h0		hardwareversion As String = "00"	#tag EndProperty	#tag Property, Flags = &h21		Private processing As Boolean = false	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Baud"			Visible=true			Group="Behavior"			InitialValue="13"			Type="Integer"			EditorType="Enum"			InheritedFrom="Serial"			#tag EnumValues				"0 - 300"				"1 - 600"				"2 - 1200"				"3 - 1800"				"4 - 2400"				"5 - 3600"				"6 - 4800"				"7 - 7200"				"8 - 9600"				"9 - 14400"				"10 - 19200"				"11 - 28800"				"12 - 38400"				"13 - 57600"				"14 - 115200"				"15 - 230400"			#tag EndEnumValues		#tag EndViewProperty		#tag ViewProperty			Name="Bits"			Visible=true			Group="Behavior"			InitialValue="3"			Type="Integer"			EditorType="Enum"			InheritedFrom="Serial"			#tag EnumValues				"0 - 5 Data Bits"				"1 - 6 Data Bits"				"2 - 7 Data Bits"				"3 - 8 Data bits"			#tag EndEnumValues		#tag EndViewProperty		#tag ViewProperty			Name="commandmode"			Group="Behavior"			InitialValue="none"			Type="String"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="CTS"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="DTR"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="hardwaretype"			Group="Behavior"			Type="String"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="hardwareversion"			Group="Behavior"			InitialValue="00"			Type="String"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			Type="Integer"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="Parity"			Visible=true			Group="Behavior"			InitialValue="0"			Type="Integer"			EditorType="Enum"			InheritedFrom="Serial"			#tag EnumValues				"0 - No Parity"				"1 - Odd Parity"				"2 - EvenParity"			#tag EndEnumValues		#tag EndViewProperty		#tag ViewProperty			Name="Stop"			Visible=true			Group="Behavior"			InitialValue="0"			Type="Integer"			EditorType="Enum"			InheritedFrom="Serial"			#tag EnumValues				"0 - 1 Stop Bit"				"1 - 1.5 Stop Bits"				"2 - 2 Stop Bits"			#tag EndEnumValues		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="XON"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="Serial"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass