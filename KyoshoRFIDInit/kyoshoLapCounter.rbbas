#tag ClassProtected Class kyoshoLapCounterInherits Serial	#tag Event		Sub DataAvailable()		  //Dump the data into the buffer and then process		  		  dim rawbytes as string = me.ReadAll		  		  dim hexCode as string		  dim HexCommandCount as Integer		  		  hexCode = convertToHex(rawbytes)		  		  //Fill the array with the hex commands as they come in~		  HexCommandCount = CountFields(hexCode," ")		  for i as Integer=1 to HexCommandCount		    assembledHex.Append NthField(hexCode," ",i)		  next		  		  		  readKyoshoICData		End Sub	#tag EndEvent	#tag Method, Flags = &h0		Function checksum(data as String) As String		  dim checksum as string		  dim xornumber1 as integer		  		  for i as Integer=1 to lenb(data)		    xornumber1 = xornumber1 xor ascB(midb(data,i,1))		  next		  		  return chrB(xornumber1)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function convertToBinary(data as String) As String		  //converts and ascii hex string to a binary hex string		  dim hexPart as string		  dim hexString as string		  		  for i as Integer=1 to lenb(data) step 2		    hexPart = chrb(val("&h" + midb(data,i,2)))		    hexString=hexString+hexPart//so we don't get extra space at end throwing off command size		  next		  		  return hexString		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function convertToHex(data as string) As string		  //Turns a binary hex stream to ascii text		  		  dim hexPart as string		  dim hexString as string		  		  for i as Integer=1 to lenb(data)		    hexPart = hex(ascb(midb(data,i,1)))		    if lenb(hexPart)<2 then		      hexpart="0"+hexPart		    end if		    if i<>lenb(data) then		      hexString=hexString+hexPart+" "		    else		      hexString=hexString+hexPart//so we don't get extra space at end throwing off command size		    end if		  next		  		  return hexString		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub inventory()		  //Inventory the RFID reader to determine if there is a RFID detected		  		  //Command sent is 35 03 36		  //Data recieved will be formatted like this if UID found		  //Byte 1 will be 5F for the start of the frame		  //Byte 2 will be A1 for the protocol		  //Byte 3 will be the length of the packet EXCLUDING checksum, typically 0B in this case		  //Bytes 4-11 will be the UID in reverse byte order		  //Byte 12 will be the checksum, calculated using XOR operation		  		  //Example response with UID E0 04 01 00 11 53 F8 2E:		  //5F A1 0B 2E F8 53 11 00 01 04 E0 DB		  		  //If no UID found command just returns a 5F		  		  commandmode = "inventory"		  		  dim invcommand as string		  invcommand = ChrB(&h35) + ChrB(&h03) + ChrB(&h36)		  me.Write(invcommand)		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub readKyoshoICData()		  //First read the data in and break it apart into an array of Hex codes to work with		  		  		  dim flagStart,flagEnd,dataStart as Integer = -1		  dim packetLength as Integer = -1		  dim temp as string		  dim uid,tempUID as string		  dim uids() as string		  dim byteCount as integer		  dim bytesStart, bytesEnd as integer		  		  bytesEnd = -1		  bytesStart = UBound(assembledhex)		  		  //Make sure we are not already analyzing data		  if processing = false then		    		    processing = true		    		    //Check which command type is happening to determine how to decode data		    select case commandmode		      		    case "inventory"		      		      'Example data		      'Sent 35 03 36		      'Received 5F A1 0B 2E F8 53 11 00 01 04 E0 DB		      'Header 5F A1 0B		      '3rd byte in header is length excluding Checksum, 0B, 11 bytes		      'Tag is reverse byte order E0 04 01 00 11 53 F8 2E		      'Final byte is checksum DB, XOR operation		      'With no tag recieved		      '5F A1 03 A2		      while bytesStart <> bytesEnd		        		        bytesStart = UBound(assembledhex)		        		        //We need to discard extraneous 5F characters, they get returned for each inventory command sent		        //But we do not want to discard the 5F that starts a real response with a UID so we need to wait until we have at least 2 bytes in the buffer		        if bytesStart > 0 then		          if assembledhex(0) = "5F" and assembledhex(1) = "5F" then		            assembledhex.Remove(0)		            //processing = false		            //return		          end if		          		        end if		        		        		        //Data may come in however at random intervals, therefor, a character by character analysis method has been put into place below		        		        for i as Integer=0 to UBound(assembledHex)		          //infoText.Text="i="+str(i)+"    UBound(assembledHex)="+str(UBound(assembledHex))		          if assembledHex(i)="5F" then		            if ubound(assembledHex)>=(i+2) then//must be enough data so far so that we can even do the check at i+6		              if assembledHex(i+1)="A1" then		                flagStart=i//valid command found, a 5F followed by A1 at the beginning of the data probably doesn't happen by chance.		                dataStart=i+2//3 ahead is where the data starts~		                		              end if		            else		              processing = false		              Return//no point continuing on, we obviously don't have the rest of what we need yet to bother checking packetLengths yet.		            end if		          end if		          		          		          if flagStart<>-1 and packetLength=-1 then//if we have a valid command coming in, and packetLength has not been decided lets decide it.		            packetLength = val("&h" +assembledHex(flagStart+2)) + 1//bytes 2 from the start describe the length		          end if		          		          if flagStart<>-1 then		            temp=temp+assembledHex(i)+" "		            		          end if		          //MsgBox "i="+str(i)+endOfLine+endOfLine+" flagStart="+str(flagStart)+endofLine+"abs(i-flagStart)+1="+str(abs(i-flagStart)+1)+endOfLine+"Packet Length="+str(packetLength)		          if abs(i-flagstart)+1=packetLength then		            flagEnd=i		            tempUID=""		            //MsgBox "Packet Length Verified (Packet Below)"+EndOfLine+EndOfLine+temp		            		            //Do stuff to get UID here, -1 on flagEnd because we ignore checksum.		            for k as Integer=(flagEnd-1) downto dataStart		              byteCount=byteCount+1		              tempUID=tempUID+assembledHex(k)		              if byteCount=8 then		                //MsgBox "UID="+tempUID		                uids.Append tempUID		                byteCount=0		                tempUID=""		                //if k-1>dataStart then		                //k=k-2//skip 2 positions now, the third will be where we start again correctly when loop comes around~		                //end if		              end if		            next		            		            //Erase this section now		            for  k as Integer=1 to flagstart + packetLength		              assembledHex.Remove(0)//keeps removing until it's gotten to the packetLength, leaving just anything else that may be there for analysis next round or perhaps this round still.		            next		            		            temp=""		            for k as Integer=0 to UBound(assembledHex)		              temp=temp+assembledHex(k)		            next		            //MsgBox "assembledHex Test="+EndOfLine+EndOfLine+temp		            		            if UBound(uids) <> -1 then		              DetectedUIDs(uids)		            end if		            		            //Clear Variables		            flagStart=-1		            flagEnd=-1		            packetLength=-1		            dataStart=-1		            temp=""		            tempUID=""		            //errorText.Text="Assemble Completed"		          end if		        next		        		        bytesEnd = UBound(assembledhex)		        		      wend		      		    case "write"		      //A successful write will send a response looking like this:		      //5F A7 04 00 A3		      		      for i as Integer=0 to UBound(assembledHex)		        if assembledHex(i)="5F" then		          if UBound(assembledhex) > i + 3 then		            		            if assembledhex(i)="5F" and assembledhex(i+1)="A7" and assembledhex(i+2)="04" and assembledhex(i+3)="00" and assembledhex(i+4)="A3" then		              //beginning of a packet, we hope		              flagStart = i		              logging("Write successful")		            end if		            		          else		            //not enough data return		            return		          end if		        end if		      next		      		      if flagStart <> -1 then		        //remove data because we found usefull information		        for k as Integer = 1 to flagstart + 5		          assembledhex.Remove(0)		        next		      end if		      		      flagStart=-1		      		    else		      //We are getting data but no command was issued, discard data		      ReDim assembledhex(-1)		      		      		    end select		    		  end if		  		  //done processing set to false		  processing = false		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub writeToRFID(blocknumber as integer, blockdata as string, uid as string)		  //write a block of data to the RFID		  //blocks are 4 bytes long		  //the first block on a tag is block 0		  		  //Command to write a block is formatted like this:		  //Byte 1 is 37 for the start of the frame		  //Byte 2 is 10 for the length of the packet INCLUDING the checksum		  //Byte 3 is the data block number being written to but is based on 0 being the first block		  //Bytes 4-7 are the data to be written		  //Bytes 8-15 are the UID to be written to in reverse byte order		  //Byte 16 is the checksum calculated using a XOR operation		  		  //An example with the word Test in block 3 would look like this		  //37 10 03 54 65 73 74 06 BD E3 1C 00 01 04 E0 B3		  		  //A succesfull response would look like this:		  //5F A7 04 00 A3		  		  commandmode = "write"		  		  //We have to convert the block numbers to the correct format		  dim hexblockdata as string		  dim hexblocknumber as string		  dim command as string		  		  hexblockdata = convertToBinary(blockdata)		  hexblocknumber = chrb(blocknumber)		  		  //We must also convert the UID to a binary data stream and reverse the bytes		  dim hexUID as string		  dim temphexUID as string		  hexUID = convertToBinary(uid)		  for i as Integer = lenb(hexUID) DownTo 1		    temphexUID = temphexUID + midb(hexUID,i,1)		  next		  hexUID = temphexUID		  		  command = ChrB(&h37) + ChrB(&h10) + hexblocknumber + hexblockdata + hexUID		  		  command = command + checksum(command)		  		  logging("Writing Block " + str(blocknumber))		  		  me.Write(command)		End Sub	#tag EndMethod	#tag Hook, Flags = &h0		Event DetectedUIDs(uids() as string)	#tag EndHook	#tag Hook, Flags = &h0		Event logging(message as string)	#tag EndHook	#tag Property, Flags = &h0		#tag Note			Buffered data goes here		#tag EndNote		assembledhex() As string	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			Defines which command was sent to the reader so we know how to decode the data		#tag EndNote		commandmode As string	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			Used to prevent us from processing data in multiple instance of an event simultaniously		#tag EndNote		processing As Boolean	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Baud"			Visible=true			Group="Behavior"			InitialValue="13"			Type="Integer"			EditorType="Enum"			InheritedFrom="Serial"			#tag EnumValues				"0 - 300"				"1 - 600"				"2 - 1200"				"3 - 1800"				"4 - 2400"				"5 - 3600"				"6 - 4800"				"7 - 7200"				"8 - 9600"				"9 - 14400"				"10 - 19200"				"11 - 28800"				"12 - 38400"				"13 - 57600"				"14 - 115200"				"15 - 230400"			#tag EndEnumValues		#tag EndViewProperty		#tag ViewProperty			Name="Bits"			Visible=true			Group="Behavior"			InitialValue="3"			Type="Integer"			EditorType="Enum"			InheritedFrom="Serial"			#tag EnumValues				"0 - 5 Data Bits"				"1 - 6 Data Bits"				"2 - 7 Data Bits"				"3 - 8 Data bits"			#tag EndEnumValues		#tag EndViewProperty		#tag ViewProperty			Name="commandmode"			Group="Behavior"			Type="string"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="CTS"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="DTR"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			Type="Integer"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="Parity"			Visible=true			Group="Behavior"			InitialValue="0"			Type="Integer"			EditorType="Enum"			InheritedFrom="Serial"			#tag EnumValues				"0 - No Parity"				"1 - Odd Parity"				"2 - EvenParity"			#tag EndEnumValues		#tag EndViewProperty		#tag ViewProperty			Name="processing"			Group="Behavior"			InitialValue="0"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="Stop"			Visible=true			Group="Behavior"			InitialValue="0"			Type="Integer"			EditorType="Enum"			InheritedFrom="Serial"			#tag EnumValues				"0 - 1 Stop Bit"				"1 - 1.5 Stop Bits"				"2 - 2 Stop Bits"			#tag EndEnumValues		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InheritedFrom="Serial"		#tag EndViewProperty		#tag ViewProperty			Name="XON"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="Serial"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass